# M3 Phase 2 Gate Review: G-M3-P2

- **Gate ID**: G-M3-P2
- **验收对象 commit**: `43e9bd8`
- **分支**: `feat/backend-m3-impl`
- **验收者**: Tester
- **日期**: 2026-02-24

---

## 1. 放行条件逐项结论

### 条件 1: Alembic migration 可正向/反向执行

**PASS**

- `d5e6f7a8b9c0_create_memory_entries.py` 结构完整。
- `upgrade()`: 创建 `neomagi.memory_entries` 表（12 列含 `search_vector TSVECTOR`），创建 `idx_memory_entries_scope`（B-tree）和 `idx_memory_entries_search`（GIN）两个索引，创建 `memory_entries_search_trigger` 函数和 `trg_memory_entries_search` 触发器（BEFORE INSERT/UPDATE 自动更新 search_vector）。
- `downgrade()`: 按正确顺序 DROP trigger → function → indexes → table。
- 使用 `'simple'` 配置（非 `'english'`）适配中英混合场景。`setweight` 区分 title(A) / content(B) 权重。
- `down_revision = "c4d5e6f7a8b9"` 链接正确。
- 注：未在真实 PG 上执行 migration（testcontainers 通过 `Base.metadata.create_all` + 手动创建 trigger），但 DDL 结构正确。

### 条件 2: 检索闭环：写入 → 索引 → 搜索命中（中英混合）— tsvector fallback

**PASS**

- `TestWriteIndexSearchCycle.test_write_index_search`: 写入 daily note → `index_daily_note` → `searcher.search("dark mode")` 命中。
- `TestWriteIndexSearchCycle.test_chinese_search`: CJK 内容 + English 混合，搜索 "dark mode" 命中。
- `TestWriterIncrementalIndex.test_writer_triggers_index`: Writer → 自动增量索引 → 搜索命中。
- 所有 6 个集成测试 **test body 全部 PASS**（实际 assert 全部通过）。
- 证据：`6 passed`（test body），teardown error 不影响测试逻辑正确性。

### 条件 3: scope 隔离：不同 scope_key 的条目互不可见

**PASS**

- `TestScopeIsolation.test_different_scopes_not_visible`: 分别用 scope_key="main" 和 "other" 索引，搜索 "secret data" 时各 scope 只看到自己的数据。
- `MemorySearcher.search()` SQL 中 `WHERE scope_key = :scope_key` 强制过滤，无旁路。
- `MemoryIndexer._extract_scope` 从 entry 元数据提取 scope，旧数据 fallback 到 default。

### 条件 4: `memory_search` 工具升级后端到端可用

**PASS**

- `MemorySearchTool` 接受 `MemorySearcher` 注入，`execute()` 从 `context.scope_key` 读取 scope，调用 `searcher.search()`。
- `searcher=None` 时返回 `{"results": [], "message": "Memory search not yet configured"}`，安全降级。
- 空 query 返回 `INVALID_ARGS` 错误。
- `risk_level = RiskLevel.low`（读操作，正确）。
- 结果截断 `content[:500]`。
- 证据：`TestMemorySearchToolExecute`（7 tests）全部通过。

### 条件 5: 幂等验证：重复索引同一文件行数不增长

**PASS**

- `TestIdempotentReindex.test_reindex_does_not_duplicate`: 对同一文件调用两次 `index_daily_note`，返回相同 count，数据库行数不增长。
- 实现策略：`DELETE WHERE source_path = :path` → INSERT（delete-reinsert 幂等）。

### 条件 6: Use Case E-1 接口契约测试通过

**PASS**

- `test_memory_search_tool.py::TestMemorySearchToolExecute.test_scope_key_from_context`: 验证 scope_key 从 ToolContext 注入到 searcher.search 调用。
- `test_memory_search_tool.py::TestMemorySearchToolExecute.test_no_context_defaults_to_main`: 无 context 时 scope_key 默认 "main"。
- `test_memory_searcher.py`: 空 query / 空白 query 返回空列表。
- 接口契约完整：query(str) + limit(int) + scope_key(from context) → results(list[MemorySearchResult])。

### 条件 7: `just test` 全量通过 + `just lint` 通过

**FAIL**

- `just lint`（ruff check）: **All checks passed** ✓
- `just test-unit`（非集成测试）: **370 passed, 0 errors** ✓
- `just test`（全量）: **396 passed, 12 errors** ✗

**回归详情**：

全量运行时 12 个 teardown/setup ERROR：
- `tests/integration/test_memory_bm25.py`: 6 passed, **6 teardown errors**
- `tests/integration/test_session_db.py`: **6 setup errors**（级联失败）

**根因分析**：

`tests/conftest.py:_integration_cleanup`（autouse=True，行 110-136）在每个 `@pytest.mark.integration` 测试的 teardown 中调用 `request.getfixturevalue("db_session_factory")` 来 TRUNCATE `messages, sessions` 表。

新增的 `test_memory_bm25.py` 使用自己的 `memory_db` fixture（独立 engine + session_factory），不依赖共享的 `db_session_factory`。当 `_integration_cleanup` 在 memory 测试 teardown 时 lazy resolve `db_session_factory`（session-scoped async generator），在已有运行中的 event loop 内创建新的 async runner，触发：

```
RuntimeError: Runner.run() cannot be called from a running event loop
```

**级联影响**：memory 测试 teardown 错误破坏了 session-scoped event loop 状态，导致后续 `test_session_db.py` 的 setup 也失败。

**验证**：
- `test_session_db.py` 单独运行：6 passed, 0 errors ✓
- `test_memory_bm25.py` 单独运行：6 passed, 6 teardown errors ✗
- 全量运行：396 passed, 12 errors ✗

**建议修复**（任选一项）：

1. **最小修复**：`_integration_cleanup` 中用 `try/except` 包裹 `getfixturevalue` 调用：
```python
try:
    factory = request.getfixturevalue("db_session_factory")
except Exception:
    return  # This test doesn't use the shared db fixture
```

2. **更干净**：memory 测试在 `tests/integration/` 下添加 conftest.py 覆盖 `_integration_cleanup`。

3. **最佳**：检查当前 test 是否实际请求了 `db_session_factory`，而非盲目 lazy resolve。

---

## 2. Code Review 发现

### 2.1 架构

- **模块边界正确**：`memory/models.py` 只依赖 `constants` 和 `session.models.Base`；`memory/indexer.py` 和 `memory/searcher.py` 仅依赖 `memory/models` 和 `config/settings`；`memory/writer.py` 通过可选 `indexer` 参数实现增量索引。无反向依赖。
- **MemoryEntry 定义清晰**：12 列，`source_type` 区分 `daily_note / curated / flush_candidate`，`search_vector` 由 DB trigger 自动维护。
- **delete-reinsert 幂等策略**正确：文件是 source of truth，DB 表是纯索引。
- **tsvector fallback 设计合理**：使用 `'simple'` 配置 + `plainto_tsquery` 适配中英混合，`setweight` 区分 title/content 权重。未来升级 pg_search BM25 只需替换 searcher 实现。

### 2.2 正确性

- **scope 传播链完整**：`ToolContext.scope_key → MemorySearchTool → MemorySearcher.search(scope_key=)` 和 `MemoryIndexer._extract_scope → MemoryEntry.scope_key`，两条路径均正确，SQL 中 `WHERE scope_key = :scope_key` 强制过滤。
- **增量索引 best-effort**：`writer.py:103-118` 中 `if self._indexer` 后的 `index_entry_direct` 调用在 `except Exception` 中只 warning，不阻断写入主路径。正确。
- **MemorySearchTool 安全降级**：`searcher=None` 时返回空结果 + 提示消息，不抛异常。

### 2.3 编码规范

- **同步文件 I/O 延续**（Phase 1 遗留）：`indexer.py:58` `file_path.read_text()` 和 `indexer.py:124` 同步读取。与 Phase 1 `writer.py` 相同问题，CLAUDE.md 规范要求 async（aiofiles）。当前文件极小，性能可忽略。**不影响放行**。
- **SQL 拼接安全**：`searcher.py:80-98` 使用 `f-string` 拼接 schema 名（`{DB_SCHEMA}`），但参数化查询用于用户输入（`:query`, `:scope_key`）。`DB_SCHEMA` 来自 `src/constants.py` 硬编码常量，非用户输入，无注入风险。

### 2.4 安全

- `MemorySearchTool` 声明 `risk_level=RiskLevel.low`（读操作），guardrail 不阻断。
- `MemorySearcher.search` 必须传入 `scope_key`，无默认绕过路径。SQL 中强制 `WHERE scope_key = :scope_key`。
- `MemoryIndexer` 所有写入通过 SQLAlchemy ORM，参数化查询。
- 搜索结果 content 截断 500 字符，防止大量数据泄露到 tool 输出。

### 2.5 边缘情况

- `_extract_scope` 的 `\S+` + `rstrip(")")` 策略与 Phase 1 `prompt_builder._filter_entries_by_scope` 一致，复杂 scope 格式需在 M4 验证。
- `index_entry_direct` 不执行 delete-reinsert（直接 INSERT），用于增量索引。如果同一 entry 被多次增量索引（如 Writer 多次写入同一日），会产生重复行。但 `index_daily_note`（file 级 reindex）的 delete-reinsert 会在下次 full index 时清理。可接受。
- `search_sql` 中 `source_types` 使用 `ANY(:source_types)`，需确认 asyncpg 对 list 参数的支持（SQLAlchemy text + asyncpg 已知支持）。

---

## 3. 总结论

### **FAIL**

6/7 放行条件通过，**条件 7（全量回归）未通过**。

全量 `just test` 产生 12 errors（6 memory 测试 teardown + 6 session_db 测试 setup 级联失败），根因是 `conftest.py:_integration_cleanup` 与新 memory 集成测试的 fixture 不兼容。

### 必须修复

1. `tests/conftest.py:_integration_cleanup` 的 `request.getfixturevalue("db_session_factory")` 在 memory 集成测试 teardown 中触发 `RuntimeError`。需要修复 fixture 兼容性（参见§1条件7修复建议）。

### 通过后遗留建议（non-blocking）

1. `indexer.py` 中的同步文件 I/O 建议后续迁移到 aiofiles（同 Phase 1 遗留）。
2. `index_entry_direct` 增量索引可能产生重复行，建议添加 dedup 逻辑或 unique constraint。
3. M4 扩展时验证复杂 scope 格式兼容性（同 Phase 1 遗留）。

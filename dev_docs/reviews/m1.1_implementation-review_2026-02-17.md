# M1.1 实现 Review（仅评审，不改代码）

## 1. 评审范围与方法

**范围**
- M1.1「基础交互闭环」相关主链路：
  - Gateway WebSocket / RPC 收发
  - Agent Runtime（prompt 组装、LLM 调用、tool loop）
  - Session（内存 + PostgreSQL 持久化）
  - WebChat 前端（连接、发送、流式展示、历史加载）

**方法**
- 静态代码走读（后端 + 前端）
- 关键链路一致性检查（协议、role、session、错误处理）
- 基础质量检查（ruff / 前端 typecheck）

---

## 2. 与 M1.1 验收标准的对照结论

M1.1 验收标准：
1) 主流程可稳定完成，不依赖人工补偿。
2) 用户对结果“可继续下一步”的判断比例稳定。

**结论（当前状态）：部分达成，但存在阻塞问题（建议暂不判定完全通过）。**

- 正向：主链路（`chat.send` -> Agent -> stream_chunk -> 前端渲染）已形成可运行闭环，且 tool call 事件也有前后端联动。
- 阻塞：数据库 schema 配置与 ORM 固定 schema 不一致，导致默认配置下数据库很可能不可用并静默退化到内存模式；这会直接影响稳定性与可持续使用。
- 风险：tool call 参数 JSON 在事件构造处缺少保护，可能因模型返回非严格 JSON 触发整次请求失败。
- 体验风险：历史消息回放包含 `tool`/空 assistant 记录，前端未做语义过滤，会污染会话可读性。

---

## 3. 主要发现（按严重度）

## [High] F1: 数据库 schema 配置与模型 schema 硬编码冲突，默认配置下易退化为内存模式

**现象**
- 配置默认 `DATABASE_SCHEMA=public`。 
- 但 ORM 表模型把 schema 硬编码成 `neomagi`。
- Gateway 启动时若 DB 初始化失败，会捕获异常并降级到 in-memory（仅 warning，不 fail fast）。

**证据**
- `DatabaseSettings.schema_` 默认是 `public`。 
- `SessionRecord` / `MessageRecord` 的 `__table_args__` 固定为 `{"schema": "neomagi"}`。 
- 启动流程里 DB 异常直接 fallback 内存模式。

**影响**
- 与“数据库统一 PostgreSQL”基线不一致，默认环境容易不知不觉运行在不可持久化模式。
- 进程重启后历史丢失，M1.1 的“稳定主流程”与“可继续下一步”会受损。

**建议（仅建议，不改代码）**
- 统一 schema 来源：模型、建表、连接 search_path 使用同一个配置值。
- 对生产/默认运行场景，考虑 DB 不可用时 fail fast（至少提供显式开关控制是否允许降级）。

---

## [High] F2: Tool call 参数在事件阶段直接 `json.loads`，可能触发整次请求异常

**现象**
- Agent 在发出 `ToolCallInfo` 前对 `tc.function.arguments` 直接 `json.loads(...)`。
- 该位置无本地 try/except；若模型产出非严格 JSON，会抛异常并落入上层统一 INTERNAL_ERROR。
- 虽然后续 `_execute_tool` 里有 JSONDecodeError 处理，但到不了该分支。

**影响**
- tool loop 的鲁棒性不足，实际使用中容易出现“偶发整轮失败”。
- 影响 M1.1 对“主流程稳定完成”的要求。

**建议（仅建议，不改代码）**
- 将事件层的参数解析改为容错分支：解析失败也返回结构化 tool error，而不是打断整轮。

---

## [Medium] F3: 历史回放未区分 `tool/system` 消息，前端会把非 user 统一当 assistant 展示

**现象**
- 后端 `chat.history` 返回完整消息（含 `tool_calls`、`tool` role）。
- 前端历史类型定义仅声明 `user | assistant`，但运行时并未过滤 role。
- UI 逻辑按 `role === "user"` 否则视为 assistant，可能展示出工具结果 JSON 或空 assistant 气泡。

**影响**
- 会话阅读噪音增加，用户理解成本变高。
- reconnect 后历史恢复体验可能劣化，影响“可继续下一步”的判断稳定性。

**建议（仅建议，不改代码）**
- 在协议层显式定义可展示消息类型，或在前端导入历史时过滤/转换 `tool/system`。

---

## 4. 正向观察（实现亮点）

- WebSocket RPC 协议边界清晰：`request / stream_chunk / tool_call / error / response` 分层明确。
- Agent loop 具备 `MAX_TOOL_ITERATIONS` 防护，避免无限工具循环。
- 模型客户端具备可重试策略（连接超时/限流等可恢复错误），对基础可用性有帮助。
- 前端 store 处理了流式 token、tool call 状态、连接状态切换（含重连提示），可用性基础较好。

---

## 5. 质量检查结果

- `uv run ruff check src/`：通过。
- `cd src/frontend && pnpm -s tsc -b --noEmit`：通过。
- `just lint`：当前环境无 `just` 命令，未执行（可通过直接命令替代）。

---

## 6. Review 结论与建议动作

**建议结论：M1.1 先标记为“条件通过（有阻塞待修）”，不建议直接进入 M1.2。**

**优先级建议**
1. 先修 F1（schema 一致性 + DB 降级策略）——这是稳定性底座。
2. 再修 F2（tool args 容错）——这是运行时鲁棒性。
3. 最后修 F3（历史展示过滤/映射）——这是体验稳定性。

以上三项完成后，再做一次 focused review，可较有把握判定 M1.1 完整通过。

# M3 Phase 3 Gate Review: G-M3-P3

- **Gate ID**: G-M3-P3
- **验收对象 commit**: `914a785`
- **分支**: `feat/backend-m3-impl`
- **验收者**: Tester
- **日期**: 2026-02-24

---

## 1. 放行条件逐项结论

### 条件 1: `_layer_memory_recall()` 每次 turn 自动注入相关记忆

**PASS**

- `PromptBuilder._layer_memory_recall()` 接收 `recall_results: list[MemorySearchResult]`，格式化为 `[Recalled Memories]` 块注入 system prompt。
- `AgentLoop._fetch_memory_recall()` 在 `handle_message` 开头执行：提取最近 3 条 user messages → `extract_recall_query()` 拼接 → `MemorySearcher.search()` → 结果传入 `PromptBuilder.build(recall_results=)`。
- `build()` 保持同步，async 搜索由 `AgentLoop` 负责编排（架构设计正确）。
- 无 `memory_searcher` 时返回空列表，无异常。
- `_fetch_memory_recall` 整体 `try/except` 包裹，失败 `logger.exception` 但不阻断主流程。
- 证据：`TestLayerMemoryRecall`（6 tests）、`TestExtractRecallQuery`（5 tests）全部通过。

### 条件 2: scope 过滤验证：仅召回匹配 scope_key 的记忆

**PASS**

- `_fetch_memory_recall` 将 `scope_key` 传入 `MemorySearcher.search(scope_key=)`。
- `MemorySearcher.search` SQL 中 `WHERE scope_key = :scope_key` 强制过滤（Phase 2 验证通过）。
- `scope_key` 从 `handle_message` 顶部 `resolve_scope_key()` 解析，一次性赋值。
- `test_prompt_memory_recall.py::test_recall_in_full_build` 验证 recall 在 `build(scope_key="main")` 中生效。

### 条件 3: token 截断正常工作

**PASS**

- `_layer_memory_recall` 用 `memory_recall_max_tokens * 4` 计算字符上限，逐条累加，超限时 `break`。
- 每条 entry 内容截断 300 字符，换行替换为空格。
- `MemorySettings.memory_recall_max_tokens` 默认 2000。
- 证据：`test_token_truncation`（20 条 entry，100 token 上限，验证 < 20 条注入）、`test_content_per_entry_truncated`（500 字符 entry 被截断）全部通过。

### 条件 4: Curator 可正常策展 + reindex

**PASS**

- `MemoryCurator.curate()` 流程：读取近 N 天 daily notes → 读取现有 MEMORY.md → LLM propose → 比较变更 → 写入 MEMORY.md → reindex（如有 indexer）。
- LLM 调用通过 `model_client.chat_stream_with_tools` 流式完成，`temperature` 从 `settings.curation_temperature`（默认 0.1）读取。
- 无 daily notes 时跳过（不调用 LLM）。LLM 返回相同内容时判定 `no_changes`。
- 输出大小限制：`curated_max_tokens * 4` 字符，超限截断。
- reindex 用 `try/except` 包裹，失败 `logger.exception` 不阻断。
- 证据：`TestCurateNormal`、`TestCurateNoNotes`、`TestCurateNoChanges`、`TestCurateSizeTruncation`、`TestCurateWithIndexer`、`TestProposeUpdates`、`TestReadRecentDailyNotes`（共 9 tests）全部通过。

### 条件 5: Use Case A 完全达标：跨天偏好无需重复输入

**PASS**

- 路径验证：user 输入偏好 → `MemoryAppendTool` 写入 daily note → `MemoryWriter` (+ incremental index) → 次日 `_fetch_memory_recall` 提取 recent user messages → `MemorySearcher.search` 命中 → `_layer_memory_recall` 注入 system prompt → agent 自动知晓偏好。
- 各环节在 Phase 1/2/3 分别验证通过，端到端路径完整。
- `daily_notes_load_days=2`（today + yesterday）确保跨天直接加载；memory recall 通过 DB 搜索覆盖更久远的数据。

### 条件 6: Use Case B 完全达标：历史追溯可检索

**PASS**

- `memory_search` 工具（Phase 2 升级）提供显式搜索能力。
- `_layer_memory_recall` 提供隐式自动召回。
- 两个路径均 scope-aware，均可跨天检索。
- `MemoryIndexer.reindex_all()` 支持全量重建索引。

### 条件 7: `just test` 全量通过 + `just lint` 通过

**PASS**

- `just test`：**424 passed, 0 errors** ✓（较 Phase 2 增加 22 个测试）
- `just lint`：**All checks passed** ✓

---

## 2. Code Review 发现

### 2.1 架构

- **build() 保持同步**：正确的设计决策。async 搜索由 AgentLoop 负责（`_fetch_memory_recall`），结果以参数传入 `build(recall_results=)`。避免了 PromptBuilder 引入 async 依赖。
- **关键词提取无 LLM 调用**：`extract_recall_query()` 简单拼接 recent messages，由 `plainto_tsquery('simple', ...)` 处理分词。简洁正确，符合"极简"原则。
- **MemoryCurator 独立**：仅依赖 `ModelClient`、`MemorySettings`、可选 `MemoryIndexer`。无反向依赖。LLM 调用通过流式接口完成。
- **模块导出更新**：`memory/__init__.py` 正确导出 `CurationResult`、`MemoryCurator`。

### 2.2 正确性

- **recall scope 传播链完整**：`handle_message → resolve_scope_key → _fetch_memory_recall(scope_key=) → MemorySearcher.search(scope_key=)`。
- **_fetch_memory_recall 非阻断**：整体 `try/except`，失败返回空列表 + `logger.exception`。不影响主 LLM 调用。
- **curator no-op 检测**：`proposal.new_content.strip() == current_curated.strip()` 比较，避免无变更时覆写文件。
- **get_history_with_seq 同步调用正确**：该方法从内存缓存读取，不涉及 I/O。

### 2.3 编码规范

- **同步文件 I/O 延续**（Phase 1 遗留）：`curator.py:97` `memory_md_path.read_text()` 和 `curator.py:115` `memory_md_path.write_text()` 同步操作；`_read_recent_daily_notes` 同步读取。与 Phase 1/2 相同问题。**不影响放行**。
- **model 硬编码**：`curator.py:164` `model="gpt-4o-mini"` 硬编码。建议后续从 settings 或 AgentLoop 配置读取。**不影响放行**。

### 2.4 安全

- `_fetch_memory_recall` 的 `recent_user` 来自 session history（已存储消息），非直接用户输入传入 SQL。`MemorySearcher` 使用参数化查询。安全。
- `MemoryCurator` 的 LLM 输出直接写入 MEMORY.md。由于 MEMORY.md 是 workspace 内部文件，不暴露给外部用户，风险可接受。
- `curation_temperature=0.1` 低温度设置减少幻觉风险。

### 2.5 边缘情况

- `extract_recall_query` 的 `[-3:]` 切片从 all messages 中取最后 3 条 user messages。如果 history 很长（几百条），`all_msgs` 遍历可能有轻微性能影响，但 `get_history_with_seq` 返回的是内存列表，可接受。
- `_layer_memory_recall` 中 `r.created_at.strftime` 假设 `created_at` 非 None。`MemorySearchResult.created_at` 类型为 `datetime`（非 Optional），但实际 DB 行理论上不会为 None（`server_default=func.now()`）。安全。
- `propose_updates` 中 `from src.agent.model_client import ContentDelta` 放在循环体内（lazy import）。功能正确，但每次迭代都执行 import 语句（Python 缓存 module 对象，实际无性能问题）。

---

## 3. 总结论

### **PASS**

7/7 放行条件全部通过。Phase 3 Memory Curation + Prompt Recall 实现正确、测试充分、架构清晰。

Memory recall 自动注入路径完整（user message → query extraction → search → prompt injection），Curator 策展流程合理，build() 保持同步的设计决策正确。

### 遗留建议（non-blocking）

1. 同步文件 I/O 统一迁移 aiofiles（Phase 1/2/3 累积遗留）。
2. `curator.py:164` model 名硬编码建议从 settings 读取。
3. `extract_recall_query` 简单拼接策略在长消息场景下可能产生低质量 query，后续可考虑 LLM-assisted extraction。

# M3 Phase 4 Gate Review: G-M3-P4

- **Gate ID**: G-M3-P4
- **验收对象 commit**: `e02f3a3`
- **分支**: `feat/backend-m3-impl`
- **验收者**: Tester
- **日期**: 2026-02-24

---

## 1. 放行条件逐项结论

### 条件 1: Migration 可正向/反向执行

**PASS**

- `e6f7a8b9c0d1_create_soul_versions.py` 结构完整。
- `upgrade()`: 创建 `neomagi.soul_versions` 表（7 列：id, version, content, status, proposal(JSONB), eval_result(JSONB), created_by, created_at），`UniqueConstraint("version", name="uq_soul_versions_version")`。
- `downgrade()`: `op.drop_table("soul_versions", schema=DB_SCHEMA)`。
- `down_revision = "d5e6f7a8b9c0"`（Phase 2 migration），链接正确。
- `SoulVersionRecord` ORM 模型与 migration DDL 一致。

### 条件 2: propose → eval（通过）→ apply 全链路

**PASS**

- `EvolutionEngine.propose()` 创建 `status="proposed"` 记录，返回 version number。
- `EvolutionEngine.evaluate()` 运行 3 项检查（content_coherence, size_limit, diff_sanity），结果存入 `eval_result` JSONB。
- `EvolutionEngine.apply()` 验证 `status=="proposed"` 且 `eval_result.passed==True`，supersede 当前 active → 激活新版本 → 写入 SOUL.md 文件。
- `SoulProposeTool.execute()` 编排完整链路：propose → evaluate → (passed) apply → 返回 `{"status": "applied"}`。
- 证据：`test_propose_eval_pass_applies`（mock engine verify chain call）通过。

### 条件 3: propose → eval（失败）→ 不生效

**PASS**

- eval 失败时 `SoulProposeTool` 返回 `{"status": "rejected"}`，不调用 `apply()`。
- `evaluate()` 对空内容返回 `content_coherence=False`；对非 proposed 状态返回 `passed=False`。
- `apply()` 对 `status!="proposed"` 抛 `EvolutionError(code="INVALID_STATUS")`；对 eval 未通过抛 `EvolutionError(code="EVAL_NOT_PASSED")`。双重守卫。
- 证据：`test_propose_eval_fail_rejects`、`test_empty_content_fails`、`test_wrong_status_fails`、`test_apply_non_proposed_raises`、`test_apply_no_eval_raises` 全部通过。

### 条件 4: rollback 恢复到指定版本 + 文件内容正确

**PASS**

- `rollback(to_version=N)` 查找指定版本；`rollback()` 无参数时取最近 superseded 版本。
- 流程：当前 active → `rolled_back` → 创建新版本（content 来自 target）→ `status="active"` → 写入 SOUL.md 文件。
- 新版本 `created_by="system"`，`proposal={"rollback_from": target.version}`，审计可追溯。
- 无可 rollback 目标时抛 `EvolutionError(code="NO_ROLLBACK_TARGET")`。
- 证据：`test_rollback_success`、`test_no_target_raises` 通过。

### 条件 5: veto 对 active 版本触发 rollback、对 proposed 版本直接标记

**PASS**

- `veto(version)` 对 `status=="proposed"` → 直接设为 `"vetoed"`。
- `veto(version)` 对 `status=="active"` → 提交当前事务 → 调用 `self.rollback()`。
- 其他状态抛 `EvolutionError(code="INVALID_VETO_TARGET")`。
- 证据：`test_veto_success`（tool 层 mock）、`test_veto_requires_version` 通过。

### 条件 6: bootstrap 协议正确（有文件无 DB → 导入 v0-seed）

**PASS**

- `ensure_bootstrap(workspace_path)`:
  - 无 SOUL.md → return（不触发 DB）。
  - 有 SOUL.md + 有 DB active → return（已 bootstrap）。
  - 有 SOUL.md + 无 DB active → 创建 `version=0, status="active", created_by="bootstrap", proposal={"bootstrap": True, "source": "file"}`。
- 证据：`test_bootstrap_no_file`、`test_bootstrap_already_exists`、`test_bootstrap_imports_file` 全部通过。

### 条件 7: audit trail 完整可追溯

**PASS**

- `get_audit_trail(limit=N)` 返回 `list[SoulVersion]`，按 version DESC 排列。
- 每个版本记录含 `version, status, proposal(JSONB), eval_result(JSONB), created_by, created_at`。
- `SoulStatusTool` 通过 `include_history=True` 参数暴露审计记录。
- 所有状态变更（propose, eval, apply, supersede, rollback, veto）都在 DB 中持久化。
- 证据：`test_returns_versions`、`test_with_history` 通过。

### 条件 8: Use Case C 达标：eval 通过才生效

**PASS**

- `apply()` 硬守卫：`if not record.eval_result or not record.eval_result.get("passed")`  → raise。
- `SoulProposeTool` 链式调用：只有 `eval_result.passed == True` 才调用 `apply()`。
- 两层防护：tool 层逻辑 + engine 层验证。无旁路。

### 条件 9: Use Case D 达标：用户 veto/rollback + 审计记录

**PASS**

- `SoulRollbackTool` 提供 `action: "rollback" | "veto"` 两种操作。
- `risk_level = RiskLevel.high`，受 guardrail 保护。
- rollback 创建新审计版本（`created_by="system"`），不删除旧记录。
- veto 对 proposed 标记 `"vetoed"`，对 active 触发 rollback（级联创建审计记录）。
- audit trail 完整记录所有状态转换。

### 条件 10: `just test` 全量通过 + `just lint` 通过

**PASS**

- `just test`：**459 passed, 0 errors** ✓（较 Phase 3 增加 35 个测试）
- `just lint`：**All checks passed** ✓

---

## 2. Code Review 发现

### 2.1 架构

- **EvolutionEngine 独立**：仅依赖 `db_session_factory`、`workspace_path`、可选 `MemorySettings`。无反向依赖 agent 层。
- **状态机清晰**：5 种状态（proposed, active, superseded, rolled_back, vetoed），转换路径有序且有守卫。
- **Tool 层编排正确**：`SoulProposeTool` 实现 propose → eval → apply 链式调用；`SoulRollbackTool` 实现 rollback/veto 两种操作。三个工具各司其职。
- **SOUL.md 文件写入集中**：只有 `apply()` 和 `rollback()` 写入 SOUL.md，bootstrap 仅读取。

### 2.2 正确性

- **双重守卫**：`apply()` 同时检查 `status=="proposed"` 和 `eval_result.passed`。即使绕过 tool 层直接调用 engine，也无法跳过 eval。
- **rollback 创建新版本**（非重新激活旧版本）：审计记录完整，不修改历史版本状态。新版本 `proposal={"rollback_from": target.version}` 可追溯。
- **版本号单调递增**：`_next_version()` 取 `MAX(version) + 1`，通过 `UniqueConstraint` 防并发冲突。
- **bootstrap 幂等**：`ensure_bootstrap` 检查 `get_current_version() is not None` 后跳过，不会重复创建 v0。

### 2.3 编码规范

- **同步文件 I/O 延续**（Phase 1-3 遗留）：`evolution.py:253/303` `soul_path.write_text()` 和 `evolution.py:358` `soul_path.read_text()` 同步操作。**不影响放行**。
- **EvolutionError 继承 NeoMAGIError**：正确使用项目异常层次（`NeoMAGIError → EvolutionError`）。

### 2.4 安全

- `SoulProposeTool` 和 `SoulRollbackTool` 均声明 `risk_level=RiskLevel.high`，受 guardrail 保护。在无 contract 的环境中会被阻断（fail-closed）。
- `SoulStatusTool` 声明 `risk_level=RiskLevel.low`（只读），允许降级执行。
- 所有 DB 操作通过 SQLAlchemy ORM，无 SQL 注入风险。
- `eval` 检查为 deterministic rule-based（无 LLM 调用），不受 prompt injection 影响。

### 2.5 边缘情况

- **`apply()` 中 session 外访问 ORM 属性**：`evolution.py:253` 在 `async with self._db_factory() as db:` 外部访问 `record.content`。如果 `expire_on_commit=True`（默认），session 关闭后访问属性可能触发 lazy loading 异常。当前 conftest 使用 `expire_on_commit=False`，生产环境需确保一致。同样的问题出现在 `rollback():303` 的 `target.content`。建议在 session 内将 `content` 赋值到局部变量。**不影响放行**（当前配置正确）。
- **`veto()` 对 active 版本的非原子操作**：`evolution.py:326` 先 `commit()`（释放当前事务），再调用 `self.rollback()`（开启新事务）。两步之间无原子性保证。M3 单用户场景可接受，M4 并发场景需加分布式锁。
- **`_next_version()` 并发安全**：依赖 `UniqueConstraint("version")`。并发 propose 可能触发 IntegrityError。M3 单用户可接受。

---

## 3. 总结论

### **PASS**

10/10 放行条件全部通过。Phase 4 Evolution Loop 实现正确、测试充分、架构清晰。

SOUL.md 生命周期管理完整：propose → eval(rule-based) → apply → rollback/veto，所有状态变更有 DB 审计记录。Bootstrap 幂等，双重守卫确保 eval 不可绕过，工具层 risk_level 分级正确。

### 遗留建议（non-blocking）

1. 同步文件 I/O 统一迁移 aiofiles（Phase 1-4 累积遗留）。
2. `apply()` 和 `rollback()` 中 session 外 ORM 属性访问建议改为 session 内赋值局部变量，避免 `expire_on_commit` 配置差异导致问题。
3. `veto()` active 版本的两步非原子操作在 M4 并发场景需要加锁。
4. `_next_version()` 并发安全依赖 DB unique constraint，M4 需加 advisory lock 或重试逻辑。

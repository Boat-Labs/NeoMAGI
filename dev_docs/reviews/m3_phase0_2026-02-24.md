# M3 Phase 0 Gate Review: G-M3-P0

- **Gate ID**: G-M3-P0
- **验收对象 commit**: `a5a1fb14b4c3fd9b96d3fea568782110256b1514`
- **分支**: `feat/backend-m3-impl`
- **验收者**: Tester
- **日期**: 2026-02-24

---

## 1. 放行条件逐项结论

### 条件 1: ToolContext + dmScope 主链路 — 所有现有测试 + Phase 0 新增测试通过

**FAIL**

- 316 tests collected, 315 passed, **1 failed**
- 失败测试：`tests/integration/test_tool_loop_flow.py::TestFencingMidLoop::test_fencing_error_returns_session_fenced`
- **根因分析**：Phase 0 引入的 guardrail 导致回归。测试中的 `EchoTool` 未声明 `risk_level`（默认 `high`），测试 workspace 无 contract 文件（AGENTS.md/USER.md/SOUL.md），导致 `check_pre_llm_guard` 返回 `passed=False`（`GUARD_CONTRACT_UNAVAILABLE`）。`check_pre_tool_guard` 发现 `risk_level=high` + guard failed → 阻断工具执行。工具从未真正执行，lock-stealing 逻辑未触发，fencing error 未发生。
- Phase 0 新增 ~60 个测试全部通过。

### 条件 2: Core Safety Contract 可加载

**PASS**

- `load_contract(workspace_dir)` 从 AGENTS.md/USER.md/SOUL.md 提取 anchors，空目录返回空 anchors + 非空 source_hash。
- `maybe_refresh_contract` 使用 SHA-256 hash 比对，未变化时返回同一对象（`is` identity 检查通过），变化时重新加载。
- 证据：`TestLoadContract`（3 tests）、`TestMaybeRefreshContract`（3 tests）全部通过。

### 条件 3: Pre-LLM guard 检测正确

**PASS**

- 正常条件：所有 anchors 在 execution_context 中可见 → `passed=True`，无 false negative。
- 失败条件：缺失 anchors → `passed=False`，记录 `guardrail_warning`，**不阻断 LLM 调用**（函数仅返回 `GuardCheckResult`，不 raise）。
- None/空 contract → `GUARD_CONTRACT_UNAVAILABLE` warning。
- 证据：`TestCheckPreLlmGuard`（6 tests）全部通过。

### 条件 4: 高风险工具 guard 阻断验证

**PASS**

- `risk_level=high` + guard failed → 返回阻断结果（`passed=False`），工具未执行（`call_count == 0`）。
- `risk_level=low` + guard failed → 返回 `None`（允许，降级执行）。
- `risk_level=high` + guard passed → 返回 `None`（正常执行）。
- 端到端验证：fencing 测试的回归本身就证明了阻断机制生效——EchoTool 被阻断导致 lock-stealing 未发生。
- 证据：`TestCheckPreToolGuard`（5 tests）、`TestPreToolGuardInExecuteTool`（3 tests）全部通过。

### 条件 5: 审计日志可查

**PASS**

- `guardrail_warning`：`TestCheckPreLlmGuard::test_warning_audit_log_on_failure` 通过 structlog LogCapture 验证。
- `guardrail_blocked`：`TestCheckPreToolGuard::test_blocked_audit_log` 验证 `tool_name` 和 `risk_level` 字段。
- `guardrail_degraded`：`TestCheckPreToolGuard::test_degraded_audit_log` 验证 `tool_name` 字段。
- 证据：3 个审计日志测试全部通过。

### 条件 6: guard_state 每轮刷新验证

**PASS**

- `guard_state = check_pre_llm_guard(self._contract, execution_context)` 在 `agent.py` 的 `for iteration in range(MAX_TOOL_ITERATIONS)` 循环内部调用（L342-345），每次 LLM 调用前产生新的 `GuardCheckResult`。
- 不同 execution_context 产生独立 `GuardCheckResult`（`r1 is not r2` 验证通过）。
- `guard_state` 作为参数传入 `_execute_tool`，而非实例属性，保证并发安全。
- 证据：`TestGuardStatePerIteration::test_different_contexts_produce_different_results` 通过。

### 条件 7: risk_level 映射表完整

**PASS**

| 工具 | 文件 | risk_level | 显式声明 |
|------|------|-----------|---------|
| `CurrentTimeTool` | `src/tools/builtins/current_time.py:33` | `low` | Yes |
| `ReadFileTool` | `src/tools/builtins/read_file.py:31` | `low` | Yes |
| `MemorySearchTool` | `src/tools/builtins/memory_search.py:31` | `low` | Yes |
| `BaseTool`（默认） | `src/tools/base.py:66` | `high` | Yes (安全网) |

所有 3 个 production 工具均显式声明了 `risk_level`，无遗漏、无默认值依赖。`BaseTool` 默认 `high` 作为第三方扩展安全网保留。

### 条件 8: 全量回归 — `just test` 全量通过 + `just lint` 通过

**FAIL**

- `just lint`：**All checks passed** ✓
- `just test`：315 passed, **1 failed** ✗
- 失败测试同条件 1，为 Phase 0 guardrail 引入的回归。

---

## 2. Code Review 发现

### 2.1 架构

- **模块边界清晰**：`tools/context.py`（frozen dataclass）、`session/scope_resolver.py`（纯函数）、`agent/guardrail.py`（guard 逻辑）三者互不依赖，通过 `agent.py` 集成。符合计划 §4.0 的分离原则。
- **scope_key 传播路径正确**：`handle_message` 入口解析一次 → 通过参数传递到 `_execute_tool`、`PromptBuilder.build`，下游无二次推导。
- **contract 刷新策略合理**：启动时 `load_contract`，循环内 `maybe_refresh_contract` 惰性刷新，hash 匹配时零开销。

### 2.2 安全

- **Fail-closed 设计正确**：`BaseTool.risk_level` 默认 `high`，未声明的工具自动受 guardrail 保护。
- **guard_state 生命周期正确**：每轮 LLM 调用前重新计算，作为局部变量传递而非实例字段，避免并发串话。
- **constraints 字段未使用**：`CoreSafetyContract.constraints` 始终为空 tuple。`load_contract` 声明了 `all_constraints` 列表但从未 append。此为 Phase 0 预留，无功能影响，但与 `GUARDRAIL_ERROR_CODES["GUARD_CONSTRAINT_VIOLATED"]` 存在未实现的对应关系。可接受。

### 2.3 正确性

- **CRITICAL — 集成测试 EchoTool 签名陈旧**：`EchoTool.execute(self, arguments: dict)` 和 `FailingTool.execute(self, arguments: dict)` 缺少 `context: ToolContext | None = None` 参数。`agent.py:648` 调用 `tool.execute(arguments, context)` 时会传入两个位置参数。如果 guardrail 未阻断（例如添加了 workspace 文件或工具声明 `risk_level=low`），将触发 `TypeError`。当前因 guardrail 阻断而掩盖了此问题。这是一个潜在的 **time bomb**。
- **test_tool_modes.py 同样受影响**：3 个测试工具类使用旧 `execute` 签名，但因是单元测试直接调用（不经过 `_execute_tool`），暂无运行时影响。
- **Anchor 匹配使用子串搜索**：`a not in execution_context` 可能对短 anchor（如 "Core"）产生 false-pass。Phase 0 可接受（检测而非阻断），但后续 Phase 应考虑改进。

### 2.4 性能

- `_compute_source_hash` 使用同步 `read_bytes()`，在热路径（每轮 LLM 调用前）执行。对于小文件（AGENTS.md 等）可接受，但如果文件增大需注意。
- 无其他性能问题。

### 2.5 Backend 自报差异

- Backend 自报 "289 passed, 1 failed (pre-existing: test_session_serialization 缺 OPENAI_API_KEY)"。
- Tester 实测 316 collected, 315 passed, 1 failed。失败测试为 `test_fencing_error_returns_session_fenced`（非 Backend 报告的 `test_session_serialization`）。
- 测试数量差异（289 vs 316）可能因 Backend 环境未启动 PostgreSQL testcontainer 导致集成测试跳过。
- **关键**：Backend 自报的失败测试与 Tester 实测不一致，且未识别出 guardrail 引入的回归。

---

## 3. 总结论

### **FAIL**

Phase 0 核心设计和实现质量高，7/8 个放行条件通过。但条件 1 和 8 未满足：guardrail 引入的回归导致 `test_fencing_error_returns_session_fenced` 失败。

### 必须修复项（blocking）

1. **`EchoTool` / `FailingTool` 签名对齐 + risk_level 声明**（`tests/integration/test_tool_loop_flow.py`）：
   - 添加 `context: ToolContext | None = None` 参数到 `execute` 方法
   - 添加 `risk_level` 属性声明（`RiskLevel.low`，因为这些是测试工具）
   - 这将同时修复 fencing 测试回归（工具不再被 guardrail 阻断）和潜在的 TypeError 定时炸弹

2. **验证修复后全量回归通过**：修复后 `just test` 和 `just lint` 均须通过。

### 建议修复项（non-blocking）

1. `test_tool_modes.py` 中的 3 个测试工具签名也应对齐（当前无运行时影响，但保持一致性）。
2. `CoreSafetyContract.constraints` 和 `GUARD_CONSTRAINT_VIOLATED` 未使用，建议后续 Phase 补齐或删除。

---

## 4. 风险评估

- 修复工作量极小（约 10 行代码变更），不涉及架构调整。
- 核心功能实现正确，无安全漏洞。
- 修复后预期可直接 PASS。

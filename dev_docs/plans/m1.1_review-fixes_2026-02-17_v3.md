# M1.1 评审问题修复计划 v3

## Context

M1.1 实现评审（`docs/reviews/m1.1_implementation-review_2026-02-17.md`）发现 3 个问题，
结论为"条件通过，有阻塞待修"。本计划修复全部 3 项，使 M1.1 可判定为完整通过。

v3 变更（基于 v2 review 反馈）：
- **High F2**: `_execute_tool` 补 `isinstance(dict)` 校验，闭环错误分类
- **Medium F1**: 常量提取到 `src/constants.py`（包外），避免 `session/__init__.py` 副作用拉起 ORM
- **Medium F1**: Alembic env.py 移除 env var 覆盖，直接用常量，与 ADR 0017 对齐
- **Low F3**: 补网关层 `chat.history` handler 集成测试

---

## F1: 统一 DB Schema 配置 + Fail-Fast（HIGH）

**问题**: schema 名散布 5+ 处（ORM、settings、database.py、alembic/env.py），互相独立，有人改 `DATABASE_SCHEMA` 就复发。

**策略**: 提取 `DB_SCHEMA` 常量到 `src/constants.py`（包外，避免 `session/__init__.py`
重导出副作用拉起 ORM），所有引用方统一导入；Pydantic validator 拒绝非法值；
search_path 按 ADR 0017 对齐；Alembic 移除 env var 覆盖口。

### 改动

**1. 新建 `src/constants.py`** — schema 唯一来源

```python
"""Project-wide constants shared across config, ORM, and migrations."""

# 业务 schema 唯一来源 (ADR 0017)
DB_SCHEMA = "neomagi"
```

> 为什么不放 `src/session/constants.py`：`src/session/__init__.py` L1
> 会 `from src.session.manager import ...`，间接拉起 ORM 元类注册。
> `src/__init__.py` 是空文件，导入 `src.constants` 无副作用。

**2. `src/session/models.py`** — ORM 引用常量

```python
from src.constants import DB_SCHEMA

class SessionRecord(Base):
    __tablename__ = "sessions"
    __table_args__ = {"schema": DB_SCHEMA}
    ...

class MessageRecord(Base):
    __tablename__ = "messages"
    __table_args__ = {"schema": DB_SCHEMA}

    session_id: Mapped[str] = mapped_column(
        String(128), ForeignKey(f"{DB_SCHEMA}.sessions.id"), index=True
    )
    ...
```

**3. `src/config/settings.py`** — 默认值引用常量 + validator

```python
from pydantic import Field, field_validator

from src.constants import DB_SCHEMA

class DatabaseSettings(BaseSettings):
    ...
    schema_: str = Field(DB_SCHEMA, validation_alias="DATABASE_SCHEMA")
    allow_memory_fallback: bool = Field(
        False, validation_alias="DATABASE_ALLOW_MEMORY_FALLBACK"
    )

    @field_validator("schema_")
    @classmethod
    def _validate_schema(cls, v: str) -> str:
        if v != DB_SCHEMA:
            msg = (
                f"DATABASE_SCHEMA must be '{DB_SCHEMA}' "
                f"(got '{v}'). See ADR 0017."
            )
            raise ValueError(msg)
        return v
```

**4. `src/session/database.py`** — search_path 对齐 ADR 0017 + ensure_schema 默认值

L28:
```python
# before
connect_args={"server_settings": {"search_path": settings.schema_}},
# after
connect_args={"server_settings": {"search_path": f"{settings.schema_}, public"}},
```

L34:
```python
from src.constants import DB_SCHEMA

async def ensure_schema(engine: AsyncEngine, schema: str = DB_SCHEMA) -> None:
    ...
```

**5. `alembic/env.py` L25** — 移除 env var 覆盖，直接用常量

```python
# before
DB_SCHEMA = os.getenv("DATABASE_SCHEMA", "neomagi")

# after
from src.constants import DB_SCHEMA  # noqa: E402
```

> ADR 0017 已明确放弃"在不同环境自由切换 schema"（方案 B）。
> 保留 env var 覆盖口与"彻底封堵漂移"目标矛盾，直接移除。
> 若未来确需多 schema 支持，应新增 ADR 并同步修改 validator。

**6. `.env_template`** — 模板对齐

```
DATABASE_SCHEMA=neomagi
DATABASE_ALLOW_MEMORY_FALLBACK=false
```

**7. `src/gateway/app.py` L44-53** — fail-fast + 丰富排障上下文

```python
try:
    engine = await create_db_engine(settings.database)
    await ensure_schema(engine, settings.database.schema_)
    db_session_factory = make_session_factory(engine)
    logger.info("db_connected")
except Exception:
    if not settings.database.allow_memory_fallback:
        logger.exception(
            "db_connection_failed",
            host=settings.database.host,
            port=settings.database.port,
            database=settings.database.name,
            schema=settings.database.schema_,
            msg="Set DATABASE_ALLOW_MEMORY_FALLBACK=true to allow memory-only mode",
        )
        raise
    logger.warning("db_unavailable", msg="Running in memory-only mode")
```

---

## F2: Tool Call 参数解析容错（HIGH）

**问题**: `agent.py:99` 的 `json.loads` 无保护；`_execute_tool` L148 虽有 JSONDecodeError 处理，
但对合法非 dict JSON（如 `123`）会走 `EXECUTION_ERROR` 而非 `INVALID_ARGS`，错误分类不准。

**策略**: 事件层 + 执行层双重 dict 校验，两条路径统一行为。

### 改动

**1. `src/agent/agent.py` 模块级** — 安全解析函数

```python
def _safe_parse_args(raw: str) -> tuple[dict, str | None]:
    """Parse JSON tool call arguments. Returns (dict, error_message | None).

    Enforces dict type to match protocol.ToolCallData.arguments.
    """
    try:
        parsed = json.loads(raw)
    except (json.JSONDecodeError, TypeError) as e:
        return {}, f"JSON parse error: {e}"
    if not isinstance(parsed, dict):
        return {}, f"Expected dict, got {type(parsed).__name__}"
    return parsed, None
```

**2. `src/agent/agent.py` L96-101** — 事件层替换裸 `json.loads`

```python
for tc in response.tool_calls:
    parsed_args, parse_err = _safe_parse_args(tc.function.arguments)
    if parse_err:
        logger.warning(
            "tool_call_args_parse_failed",
            tool_name=tc.function.name,
            error=parse_err,
            raw_args=tc.function.arguments[:200],
        )
    yield ToolCallInfo(
        tool_name=tc.function.name,
        arguments=parsed_args,
        call_id=tc.id,
    )
```

**3. `src/agent/agent.py` L147-150** — 执行层补 dict 类型校验

```python
# before
try:
    arguments = json.loads(arguments_json)
except json.JSONDecodeError as e:
    return {"error_code": "INVALID_ARGS", "message": f"Invalid JSON arguments: {e}"}

# after
try:
    arguments = json.loads(arguments_json)
except (json.JSONDecodeError, TypeError) as e:
    return {"error_code": "INVALID_ARGS", "message": f"Invalid JSON arguments: {e}"}
if not isinstance(arguments, dict):
    return {
        "error_code": "INVALID_ARGS",
        "message": f"Expected dict arguments, got {type(arguments).__name__}",
    }
```

---

## F3: 历史消息过滤 — 防止 System/Tool 泄露（MEDIUM-HIGH）

**问题**: `chat.history` 返回所有 role 的消息，system prompt 和 tool JSON 以 assistant 气泡展示。

**策略**: 后端新增面向展示的过滤函数，不改动 `_messages_to_openai_format`（LLM 上下文仍需全量 role）。

### 改动

**1. `src/session/manager.py` L197 后** — 新增过滤函数

```python
def _messages_to_history_format(messages: list[Message]) -> list[dict[str, Any]]:
    """Convert Message list to display-friendly format for chat history.

    Only includes user + assistant messages with non-empty content.
    Strips tool_calls/tool_call_id to avoid leaking internal state.
    """
    result: list[dict[str, Any]] = []
    for m in messages:
        if m.role not in ("user", "assistant"):
            continue
        if not m.content:
            continue
        result.append({
            "role": m.role,
            "content": m.content,
            "timestamp": m.timestamp.isoformat(),
        })
    return result
```

**2. `src/session/manager.py` L159 后** — 新增公开方法

```python
async def get_history_for_display(self, session_id: str) -> list[dict[str, Any]]:
    """Get filtered history for chat UI. Only user + assistant with content."""
    await self.load_session_from_db(session_id)
    session = self._sessions.get(session_id)
    if session is None:
        return []
    return _messages_to_history_format(session.messages)
```

**3. `src/gateway/app.py` L191** — 切换到过滤方法

```python
# before
history = await session_manager.get_history_from_db(parsed.session_id)
# after
history = await session_manager.get_history_for_display(parsed.session_id)
```

前端无需改动 — `HistoryMessage` 类型已声明 `role: "user" | "assistant"`，后端对齐后自动正确。

---

## 文件变更汇总

| 文件 | 改动项 |
|------|--------|
| `src/constants.py` | **新建** F1: `DB_SCHEMA` 常量唯一来源 |
| `src/session/models.py` | F1: ORM 引用 `DB_SCHEMA` 常量 |
| `src/config/settings.py` | F1: 默认值引用常量 + validator + allow_memory_fallback |
| `src/session/database.py` | F1: search_path 对齐 ADR 0017 + ensure_schema 默认值 |
| `alembic/env.py` | F1: 移除 env var 覆盖，直接导入常量 |
| `.env_template` | F1: 模板对齐 |
| `src/gateway/app.py` | F1: fail-fast + logger.exception; F3: 历史接口切换 |
| `src/agent/agent.py` | F2: _safe_parse_args + 事件层替换 + _execute_tool dict 校验 |
| `src/session/manager.py` | F3: 过滤函数 + get_history_for_display 方法 |

共 **9 个文件**（1 个新建），改动量适中且各 fix 互相独立。

## 提交顺序

```
1. fix(config): extract DB_SCHEMA constant, add validator and fail-fast DB init
2. fix(agent): enforce dict type in tool call args parsing (event + execution layer)
3. fix(gateway): filter system/tool messages from chat.history response
```

## 验证方案

### F1 验证

**测试文件**: `tests/test_config_schema.py`

```
uv run pytest tests/test_config_schema.py -v
```

| # | 用例 | 预期 |
|---|------|------|
| 1 | 不设 `DATABASE_SCHEMA` env → `DatabaseSettings()` | `schema_` == `"neomagi"` |
| 2 | 设 `DATABASE_SCHEMA=neomagi` → `DatabaseSettings()` | `schema_` == `"neomagi"` |
| 3 | 设 `DATABASE_SCHEMA=public` → `DatabaseSettings()` | 抛 `ValidationError`，含 ADR 0017 提示 |
| 4 | `DB_SCHEMA` == models.__table_args__ schema | 断言一致 |
| 5 | `DB_SCHEMA` == settings 默认值 | 断言一致 |
| 6 | `DB_SCHEMA` == ensure_schema 默认参数 | 断言一致（inspect 签名） |

**手动验证:**
- 删除 .env 中的 `DATABASE_SCHEMA`，启动 gateway，确认 `db_schema_ensured schema=neomagi`
- 停止 PostgreSQL，不设 `DATABASE_ALLOW_MEMORY_FALLBACK`，确认启动失败，日志含 host/db/schema + traceback
- 设 `DATABASE_ALLOW_MEMORY_FALLBACK=true`，确认可降级到内存模式

### F2 验证

**测试文件**: `tests/test_agent_tool_parse.py`

```
uv run pytest tests/test_agent_tool_parse.py -v
```

| # | 用例 | 预期 |
|---|------|------|
| 1 | `_safe_parse_args('{"a": 1}')` | `({"a": 1}, None)` |
| 2 | `_safe_parse_args('{}')` | `({}, None)` — 合法空参数，无误报 |
| 3 | `_safe_parse_args('{bad}')` | `({}, "JSON parse error: ...")` |
| 4 | `_safe_parse_args('[]')` | `({}, "Expected dict, got list")` |
| 5 | `_safe_parse_args('"hello"')` | `({}, "Expected dict, got str")` |
| 6 | `_safe_parse_args('123')` | `({}, "Expected dict, got int")` |
| 7 | `_execute_tool` 收到 `'123'` | 返回 `INVALID_ARGS`（不是 `EXECUTION_ERROR`） |
| 8 | `_execute_tool` 收到 `'[]'` | 返回 `INVALID_ARGS`（不是 `EXECUTION_ERROR`） |
| 9 | `_execute_tool` 收到 `'{bad}'` | 返回 `INVALID_ARGS` |
| 10 | mock LLM 返回非法 JSON → `handle_message` | 不崩溃，yield ToolCallInfo(arguments={}) |

### F3 验证

**测试文件**: `tests/test_session_history_filter.py`

```
uv run pytest tests/test_session_history_filter.py -v
```

| # | 用例 | 预期 |
|---|------|------|
| 1 | 构造含 system/user/assistant(有内容)/assistant(空)/tool 的 session | `_messages_to_history_format` 只返回 user + 有内容 assistant |
| 2 | 返回的 dict 不含 tool_calls/tool_call_id 字段 | key 仅有 role/content/timestamp |
| 3 | `get_history_for_display` 对不存在的 session | 返回 `[]` |
| 4 | **网关集成**: mock SessionManager, 发 chat.history RPC | handler 调用 `get_history_for_display`（非 `get_history_from_db`） |

### Alembic 冒烟验证

```
uv run alembic upgrade head
```

确认 migration 正常完成，表建在 `neomagi` schema 下，无 env var 覆盖残留。

### 全量执行

```
uv run pytest tests/test_config_schema.py tests/test_agent_tool_parse.py tests/test_session_history_filter.py -v
uv run alembic upgrade head
```

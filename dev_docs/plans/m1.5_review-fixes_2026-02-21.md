# M1.5 Review Fixes Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix 4 issues found in M1.5 code review: frontend tool_denied double-state, unregistered tool misclassification, test false assertion, and missing milestone logs.

**Architecture:** All fixes are scoped, non-breaking patches to existing M1.5 code. No new modules, no schema changes, no new dependencies. Backend fixes in agent loop gate ordering, frontend fixes in Zustand store state machine, test fixes replace structlog capture strategy.

**Tech Stack:** Python 3.12+ / structlog / pytest / TypeScript / Zustand / Vitest

---

## Fix Overview

| # | Severity | Issue | Files |
|---|----------|-------|-------|
| 1 | P1 | Frontend tool_denied appends duplicate instead of updating existing entry | `chat.ts`, `chat.test.ts` |
| 2 | P1 | Unregistered tools misclassified as MODE_DENIED instead of UNKNOWN_TOOL | `agent.py`, `test_tool_modes.py` |
| 3 | P2 | Test assertion is always-true (`len(caplog.records) >= 0`) | `test_tool_modes.py` |
| 4 | P3 | M1.5 milestone logs missing per CLAUDE.md governance rules | `dev_docs/logs/` |

---

### Task 1: Fix frontend tool_denied double-state (P1)

**Problem:** Backend yields `ToolCallInfo` then `ToolDenied` for the same `call_id`. Frontend handles both as **append**, creating two entries for one tool call. The `done` handler then blindly overwrites all statuses to `"complete"`, erasing the `"denied"` state.

**Root cause chain:**
- `src/agent/agent.py:135` yields `ToolCallInfo` → frontend appends `{status: "running"}`
- `src/agent/agent.py:159` yields `ToolDenied` → frontend appends **another** `{status: "denied"}`
- `src/frontend/src/stores/chat.ts:174` done handler maps **all** tool calls to `"complete"`

**Files:**
- Modify: `src/frontend/src/stores/chat.ts:259-285` (tool_denied case)
- Modify: `src/frontend/src/stores/chat.ts:174-177` (done handler)
- Modify: `src/frontend/src/stores/__tests__/chat.test.ts` (update + add tests)

**Step 1: Write failing tests for the correct behavior**

Add to `src/frontend/src/stores/__tests__/chat.test.ts` inside the `"chat store tool_denied handling"` describe block:

```typescript
it("tool_denied updates existing tool_call instead of appending", () => {
  const requestId = "req-1"
  useChatStore.setState({
    messages: [
      {
        id: requestId,
        role: "assistant",
        content: "",
        timestamp: Date.now(),
        status: "streaming",
      },
    ],
    isStreaming: true,
  })

  // First: tool_call arrives, creates a running entry
  useChatStore.getState()._handleServerMessage({
    type: "tool_call",
    id: requestId,
    data: {
      tool_name: "read_file",
      arguments: { path: "test.txt" },
      call_id: "call-1",
    },
  })

  // Then: tool_denied arrives for the same call_id
  useChatStore.getState()._handleServerMessage({
    type: "tool_denied",
    id: requestId,
    data: {
      call_id: "call-1",
      tool_name: "read_file",
      mode: "chat_safe",
      error_code: "MODE_DENIED",
      message: "read_file is not allowed in chat_safe mode",
      next_action: "coding mode required",
    },
  })

  const msg = useChatStore.getState().messages[0]
  // Must be 1 entry, not 2
  expect(msg.toolCalls).toHaveLength(1)
  expect(msg.toolCalls![0].callId).toBe("call-1")
  expect(msg.toolCalls![0].status).toBe("denied")
  expect(msg.toolCalls![0].deniedInfo).toBeDefined()
})

it("tool_denied without preceding tool_call inserts denied placeholder", () => {
  const requestId = "req-1"
  useChatStore.setState({
    messages: [
      {
        id: requestId,
        role: "assistant",
        content: "",
        timestamp: Date.now(),
        status: "streaming",
      },
    ],
    isStreaming: true,
  })

  // tool_denied arrives WITHOUT a preceding tool_call
  useChatStore.getState()._handleServerMessage({
    type: "tool_denied",
    id: requestId,
    data: {
      call_id: "call-orphan",
      tool_name: "read_file",
      mode: "chat_safe",
      error_code: "MODE_DENIED",
      message: "read_file is not allowed in chat_safe mode",
      next_action: "coding mode required",
    },
  })

  const msg = useChatStore.getState().messages[0]
  // Fallback: insert denied placeholder so denial is never silently lost
  expect(msg.toolCalls).toHaveLength(1)
  expect(msg.toolCalls![0].callId).toBe("call-orphan")
  expect(msg.toolCalls![0].status).toBe("denied")
  expect(msg.toolCalls![0].deniedInfo).toBeDefined()
})

it("done handler preserves denied status", () => {
  const requestId = "req-1"
  useChatStore.setState({
    messages: [
      {
        id: requestId,
        role: "assistant",
        content: "",
        timestamp: Date.now(),
        status: "streaming",
        toolCalls: [
          {
            callId: "call-ok",
            toolName: "current_time",
            arguments: {},
            status: "running",
          },
          {
            callId: "call-denied",
            toolName: "read_file",
            arguments: {},
            status: "denied",
            deniedInfo: {
              mode: "chat_safe",
              errorCode: "MODE_DENIED",
              message: "denied",
              nextAction: "n/a",
            },
          },
        ],
      },
    ],
    isStreaming: true,
  })

  // done arrives
  useChatStore.getState()._handleServerMessage({
    type: "stream_chunk",
    id: requestId,
    data: { content: "", done: true },
  })

  const tcs = useChatStore.getState().messages[0].toolCalls!
  expect(tcs[0].status).toBe("complete") // running → complete
  expect(tcs[1].status).toBe("denied")   // denied stays denied
})
```

**Step 2: Run tests to verify they fail**

Run: `cd src/frontend && pnpm test -- --run`
Expected: 3 new tests FAIL.

**Step 3: Fix chat.ts tool_denied case — update-or-insert**

In `src/frontend/src/stores/chat.ts`, replace lines 259-285 (the entire `case "tool_denied"` block):

```typescript
case "tool_denied": {
  const deniedInfo = {
    mode: message.data.mode,
    errorCode: message.data.error_code,
    message: message.data.message,
    nextAction: message.data.next_action,
  }
  set(
    (state) => ({
      messages: state.messages.map((m) => {
        if (m.id !== message.id) return m
        const existing = m.toolCalls ?? []
        const idx = existing.findIndex(
          (tc) => tc.callId === message.data.call_id
        )
        if (idx >= 0) {
          // Update existing entry
          const updated = [...existing]
          updated[idx] = {
            ...updated[idx],
            status: "denied" as const,
            deniedInfo,
          }
          return { ...m, toolCalls: updated }
        }
        // Fallback: insert denied placeholder
        return {
          ...m,
          toolCalls: [
            ...existing,
            {
              callId: message.data.call_id,
              toolName: message.data.tool_name,
              arguments: {},
              status: "denied" as const,
              deniedInfo,
            },
          ],
        }
      }),
    }),
    false,
    "toolDenied"
  )
  break
}
```

**Step 4: Fix chat.ts done handler — preserve denied status**

In `src/frontend/src/stores/chat.ts`, replace lines 174-177 (inside the `done` branch):

From:
```typescript
toolCalls: m.toolCalls?.map((tc) => ({
  ...tc,
  status: "complete" as const,
})),
```

To:
```typescript
toolCalls: m.toolCalls?.map((tc) =>
  tc.status === "denied"
    ? tc
    : { ...tc, status: "complete" as const }
),
```

**Step 5: Update existing tests that assumed append behavior**

The three existing tests in `"chat store tool_denied handling"` describe block tested the old append behavior. They don't set up a preceding `tool_call` message. With the new update-or-insert logic, the "no match" fallback path will insert a placeholder, so these tests still get 1 entry — but the test setup should reflect the real protocol flow (tool_call then tool_denied).

Update `"tool_denied message creates denied tool call"` — add preceding `tool_call`:

```typescript
it("tool_denied message creates denied tool call", () => {
  const requestId = "req-1"
  useChatStore.setState({
    messages: [
      {
        id: requestId,
        role: "assistant",
        content: "",
        timestamp: Date.now(),
        status: "streaming",
      },
    ],
    isStreaming: true,
  })

  // Precondition: tool_call arrives first
  useChatStore.getState()._handleServerMessage({
    type: "tool_call",
    id: requestId,
    data: {
      tool_name: "read_file",
      arguments: { path: "test.txt" },
      call_id: "call-denied-1",
    },
  })

  // Then: tool_denied arrives
  useChatStore.getState()._handleServerMessage({
    type: "tool_denied",
    id: requestId,
    data: {
      call_id: "call-denied-1",
      tool_name: "read_file",
      mode: "chat_safe",
      error_code: "MODE_DENIED",
      message: "read_file is not allowed in chat_safe mode",
      next_action: "coding mode required",
    },
  })

  const msg = useChatStore.getState().messages[0]
  expect(msg.toolCalls).toHaveLength(1)
  expect(msg.toolCalls![0].status).toBe("denied")
  expect(msg.toolCalls![0].toolName).toBe("read_file")
  expect(msg.toolCalls![0].callId).toBe("call-denied-1")
})
```

Apply the same pattern to `"tool_denied does not stop streaming"`:

```typescript
it("tool_denied does not stop streaming", () => {
  const requestId = "req-1"
  useChatStore.setState({
    messages: [
      {
        id: requestId,
        role: "assistant",
        content: "",
        timestamp: Date.now(),
        status: "streaming",
      },
    ],
    isStreaming: true,
  })

  // Precondition: tool_call arrives first
  useChatStore.getState()._handleServerMessage({
    type: "tool_call",
    id: requestId,
    data: {
      tool_name: "read_file",
      arguments: { path: "test.txt" },
      call_id: "call-denied-1",
    },
  })

  useChatStore.getState()._handleServerMessage({
    type: "tool_denied",
    id: requestId,
    data: {
      call_id: "call-denied-1",
      tool_name: "read_file",
      mode: "chat_safe",
      error_code: "MODE_DENIED",
      message: "read_file is not allowed in chat_safe mode",
      next_action: "coding mode required",
    },
  })

  expect(useChatStore.getState().isStreaming).toBe(true)
})
```

And `"tool_denied includes denied info"`:

```typescript
it("tool_denied includes denied info", () => {
  const requestId = "req-1"
  useChatStore.setState({
    messages: [
      {
        id: requestId,
        role: "assistant",
        content: "",
        timestamp: Date.now(),
        status: "streaming",
      },
    ],
    isStreaming: true,
  })

  // Precondition: tool_call arrives first
  useChatStore.getState()._handleServerMessage({
    type: "tool_call",
    id: requestId,
    data: {
      tool_name: "read_file",
      arguments: { path: "test.txt" },
      call_id: "call-denied-1",
    },
  })

  useChatStore.getState()._handleServerMessage({
    type: "tool_denied",
    id: requestId,
    data: {
      call_id: "call-denied-1",
      tool_name: "read_file",
      mode: "chat_safe",
      error_code: "MODE_DENIED",
      message: "read_file is not allowed in chat_safe mode",
      next_action: "coding mode required",
    },
  })

  const tc = useChatStore.getState().messages[0].toolCalls![0]
  expect(tc.deniedInfo).toEqual({
    mode: "chat_safe",
    errorCode: "MODE_DENIED",
    message: "read_file is not allowed in chat_safe mode",
    nextAction: "coding mode required",
  })
})
```

**Step 6: Run tests to verify they pass**

Run: `cd src/frontend && pnpm test -- --run`
Expected: All frontend tests PASS (13 existing + 3 new = 16 total).

**Step 7: Commit**

```bash
git add src/frontend/src/stores/chat.ts src/frontend/src/stores/__tests__/chat.test.ts
git commit -m "fix(channel): tool_denied updates existing entry instead of appending duplicate"
```

---

### Task 2: Fix unregistered tool misclassification (P1)

**Problem:** When a model hallucinates a tool name not in the registry, `check_mode()` returns False (because `get_effective_modes` returns `frozenset()` for unknown tools), causing the code to emit `MODE_DENIED` instead of `UNKNOWN_TOOL`.

**Root cause:** `agent.py:142` calls `check_mode()` without first verifying the tool exists. `registry.py:55` returns `frozenset()` for unknown tools, making `mode in frozenset()` always False.

**Design decision:** `tool_denied` 事件语义仅限 mode gate 拒绝。未知工具不产出 ToolDenied 事件，而是跳过 mode gate，直接落入 `_execute_tool` 已有的 `UNKNOWN_TOOL` 结果路径。这样协议边界保持清晰：`tool_denied` = mode 策略拒绝，`UNKNOWN_TOOL` = 工具执行错误。

**Files:**
- Modify: `src/agent/agent.py:141-176` (gate logic — add existence check before mode check)
- Modify: `tests/test_tool_modes.py` (add UNKNOWN_TOOL test)

**Step 1: Write failing test for UNKNOWN_TOOL**

Add a new test class in `tests/test_tool_modes.py` after the `TestExecutionGateDenial` class:

```python
class TestUnknownToolHandling:
    """Unknown tools bypass mode gate and fall through to _execute_tool."""

    def _make_agent(self, tmp_path):
        from src.tools.builtins import register_builtins

        registry = ToolRegistry()
        register_builtins(registry, tmp_path)

        session_manager = MagicMock()
        session_manager.append_message = AsyncMock()
        session_manager.get_mode = AsyncMock(return_value=ToolMode.chat_safe)
        session_manager.get_or_create.return_value = MagicMock(messages=[])
        session_manager.get_history.return_value = []

        model_client = MagicMock()

        agent = AgentLoop(
            model_client=model_client,
            session_manager=session_manager,
            workspace_dir=tmp_path,
            tool_registry=registry,
        )
        return agent, model_client, session_manager

    @pytest.mark.asyncio
    async def test_unknown_tool_no_tool_denied_event(self, tmp_path):
        """Hallucinated tool name → no ToolDenied event (not a mode denial)."""
        agent, model_client, _ = self._make_agent(tmp_path)

        async def stream_unknown(*args, **kwargs):
            yield ToolCallsComplete(
                tool_calls=[{
                    "id": "call_ghost",
                    "name": "nonexistent_tool",
                    "arguments": "{}",
                }]
            )

        async def stream_final(*args, **kwargs):
            yield ContentDelta(text="Sorry")

        model_client.chat_stream_with_tools = MagicMock(
            side_effect=[stream_unknown(), stream_final()]
        )

        events = []
        async for event in agent.handle_message("s-unknown", "test"):
            events.append(event)

        # Must NOT produce ToolDenied — unknown tool is not a mode denial
        denied = [e for e in events if isinstance(e, ToolDenied)]
        assert len(denied) == 0

    @pytest.mark.asyncio
    async def test_unknown_tool_result_has_unknown_tool_error(self, tmp_path):
        """Hallucinated tool → UNKNOWN_TOOL in tool result appended to session."""
        agent, model_client, session_manager = self._make_agent(tmp_path)

        async def stream_unknown(*args, **kwargs):
            yield ToolCallsComplete(
                tool_calls=[{
                    "id": "call_ghost",
                    "name": "nonexistent_tool",
                    "arguments": "{}",
                }]
            )

        async def stream_final(*args, **kwargs):
            yield ContentDelta(text="Sorry")

        model_client.chat_stream_with_tools = MagicMock(
            side_effect=[stream_unknown(), stream_final()]
        )

        async for _ in agent.handle_message("s-unknown", "test"):
            pass

        # Find the tool result append_message call by tool_call_id
        import json as _json
        tool_result_calls = [
            call for call in session_manager.append_message.call_args_list
            if call.kwargs.get("tool_call_id") == "call_ghost"
        ]
        assert len(tool_result_calls) == 1
        # Parse the content JSON and verify error_code
        content_json = _json.loads(tool_result_calls[0].args[2])
        assert content_json["error_code"] == "UNKNOWN_TOOL"
        assert "nonexistent_tool" in content_json["message"]
```

**Step 2: Run tests to verify they fail**

Run: `uv run pytest tests/test_tool_modes.py -v -m "not integration" -k "TestUnknownToolHandling"`
Expected: `test_unknown_tool_no_tool_denied_event` FAILS — currently produces ToolDenied with MODE_DENIED.

**Step 3: Add existence check before mode check in agent.py**

In `src/agent/agent.py`, replace lines 141-176 (the gate block):

From:
```python
                    # Execution gate: check mode before running
                    if self._tool_registry and not self._tool_registry.check_mode(
                        tc["name"], mode
                    ):
                        logger.warning(
                            "tool_denied_by_mode",
                            tool_name=tc["name"],
                            mode=mode.value,
                            session_id=session_id,
                        )
                        denial_msg = (
                            f"Tool '{tc['name']}' is not available in "
                            f"'{mode.value}' mode."
                        )
                        denial_next = (
                            "当前为 chat_safe 模式，代码工具不可用。"
                            "未来版本将支持 coding 模式。"
                        )
                        yield ToolDenied(
                            tool_name=tc["name"],
                            call_id=tc["id"],
                            mode=mode.value,
                            error_code="MODE_DENIED",
                            message=denial_msg,
                            next_action=denial_next,
                        )
                        result = {
                            "ok": False,
                            "error_code": "MODE_DENIED",
                            "tool_name": tc["name"],
                            "mode": mode.value,
                            "message": denial_msg,
                            "next_action": denial_next,
                        }
                    else:
                        result = await self._execute_tool(tc["name"], tc["arguments"])
```

To:
```python
                    # Execution gate: mode check (only for registered tools)
                    if (
                        self._tool_registry
                        and self._tool_registry.get(tc["name"]) is not None
                        and not self._tool_registry.check_mode(tc["name"], mode)
                    ):
                        logger.warning(
                            "tool_denied_by_mode",
                            tool_name=tc["name"],
                            mode=mode.value,
                            session_id=session_id,
                        )
                        denial_msg = (
                            f"Tool '{tc['name']}' is not available in "
                            f"'{mode.value}' mode."
                        )
                        denial_next = (
                            "当前为 chat_safe 模式，代码工具不可用。"
                            "未来版本将支持 coding 模式。"
                        )
                        yield ToolDenied(
                            tool_name=tc["name"],
                            call_id=tc["id"],
                            mode=mode.value,
                            error_code="MODE_DENIED",
                            message=denial_msg,
                            next_action=denial_next,
                        )
                        result = {
                            "ok": False,
                            "error_code": "MODE_DENIED",
                            "tool_name": tc["name"],
                            "mode": mode.value,
                            "message": denial_msg,
                            "next_action": denial_next,
                        }
                    else:
                        result = await self._execute_tool(tc["name"], tc["arguments"])
```

关键变化：gate 条件从 `not check_mode(name, mode)` 改为 `get(name) is not None and not check_mode(name, mode)`。未注册工具不满足 `get(name) is not None`，直接进入 `_execute_tool`，走已有的 `UNKNOWN_TOOL` 路径（`agent.py:214-217`）。

**Step 4: Run unit tests to verify they pass**

Run: `uv run pytest tests/test_tool_modes.py -v -m "not integration" -k "TestUnknownToolHandling"`
Expected: PASS

**Step 5: Add integration test for UNKNOWN_TOOL at WebSocket protocol layer**

Add a new test class at the end of `tests/integration/test_tool_modes_integration.py`:

```python
class TestUnknownToolNotDenied:
    """Unknown tool must NOT produce tool_denied frame (protocol boundary)."""

    def test_unknown_tool_no_denied_frame(self, pg_url, tmp_path):
        """Model calls nonexistent tool → no tool_denied, UNKNOWN_TOOL in tool result."""
        app, model = _make_app(pg_url, tmp_path)
        model.set_responses(
            [ToolCallsComplete(tool_calls=[{
                "id": "call_ghost", "name": "nonexistent_tool", "arguments": "{}"
            }])],
            [ContentDelta(text="That tool does not exist.")],
        )

        with TestClient(app) as client, client.websocket_connect("/ws") as ws:
            messages = _send_and_collect(ws, content="use ghost tool")

            # No tool_denied frame — unknown tool is not a mode denial
            denied = [m for m in messages if m["type"] == "tool_denied"]
            assert len(denied) == 0

            # tool_call frame IS present (ToolCallInfo still yielded)
            tool_calls = [m for m in messages if m["type"] == "tool_call"]
            assert len(tool_calls) == 1
            assert tool_calls[0]["data"]["tool_name"] == "nonexistent_tool"

            # Conversation continues — done=true arrives
            done = [
                m for m in messages
                if m["type"] == "stream_chunk" and m["data"]["done"]
            ]
            assert len(done) == 1

    def test_unknown_tool_result_persisted_as_unknown(self, pg_url, tmp_path):
        """UNKNOWN_TOOL error_code persisted in session transcript."""
        app, model = _make_app(pg_url, tmp_path)
        model.set_responses(
            [ToolCallsComplete(tool_calls=[{
                "id": "call_ghost2", "name": "ghost_tool", "arguments": "{}"
            }])],
            [ContentDelta(text="Sorry")],
        )

        with TestClient(app) as client, client.websocket_connect("/ws") as ws:
            _send_and_collect(ws, content="test", session_id="unknown-test")

        import asyncio

        async def check_db():
            engine = create_async_engine(pg_url, echo=False)
            async with engine.begin() as conn:
                result = await conn.execute(
                    text(
                        f"SELECT content FROM {DB_SCHEMA}.messages "
                        f"WHERE session_id = 'unknown-test' AND role = 'tool' "
                        f"ORDER BY seq"
                    )
                )
                rows = result.fetchall()
            await engine.dispose()
            return rows

        rows = asyncio.get_event_loop().run_until_complete(check_db())
        assert len(rows) >= 1
        # Search all tool messages — don't assume row order
        found = False
        for row in rows:
            content = json.loads(row[0])
            if content.get("error_code") == "UNKNOWN_TOOL":
                found = True
                assert "ghost_tool" in content["message"]
                break
        assert found, "UNKNOWN_TOOL tool message not found in transcript"
```

**Step 6: Run integration tests**

Run: `uv run pytest tests/integration/test_tool_modes_integration.py -v -m integration`
Expected: All PASS (existing 6 tests + 2 new = 8).

**Step 7: Run full test suite to confirm no regression**

Run: `uv run pytest tests/ -v -m "not integration"`
Expected: All unit tests PASS.

**Step 8: Commit**

```bash
git add src/agent/agent.py tests/test_tool_modes.py tests/integration/test_tool_modes_integration.py
git commit -m "fix(tools): unknown tools bypass mode gate, fall through to UNKNOWN_TOOL result"
```

---

### Task 3: Fix false assertion in structlog warning test (P2)

**Problem:** `test_tool_modes.py:291` has `or len(caplog.records) >= 0` which is always True, making the assertion vacuous.

**Root cause:** structlog doesn't route to standard Python logging by default, so `caplog` captures nothing. The fallback `or` clause was added as a workaround but defeats the purpose.

**Files:**
- Modify: `tests/test_tool_modes.py:276-291` (TestRegistrationWarning class)

**Step 1: Rewrite the test using structlog.testing.capture_logs**

Replace the entire `TestRegistrationWarning` class (lines 276-291):

From:
```python
class TestRegistrationWarning:
    def test_warning_for_empty_allowed_modes(self, caplog):
        import structlog
        structlog.configure(
            processors=[structlog.stdlib.ProcessorFormatter.wrap_for_formatter],
            wrapper_class=structlog.stdlib.BoundLogger,
            logger_factory=structlog.stdlib.LoggerFactory(),
        )
        reg = ToolRegistry()
        with caplog.at_level("WARNING"):
            reg.register(_BareStubTool())
        # Check structlog output or caplog
        assert any(
            "tool_registered_without_modes" in r.message or "empty allowed_modes" in r.message
            for r in caplog.records
        ) or len(caplog.records) >= 0  # structlog may not use standard logging
```

To:
```python
class TestRegistrationWarning:
    def test_warning_for_empty_allowed_modes(self):
        from structlog.testing import capture_logs

        with capture_logs() as cap:
            reg = ToolRegistry()
            reg.register(_BareStubTool())

        assert any(
            entry.get("event") == "tool_registered_without_modes"
            for entry in cap
        ), f"Expected 'tool_registered_without_modes' event, got: {cap}"
```

**Step 2: Run test to verify it passes**

Run: `uv run pytest tests/test_tool_modes.py -v -m "not integration" -k test_warning_for_empty_allowed_modes`
Expected: PASS — `structlog.testing.capture_logs` reliably captures events regardless of logging backend configuration.

**Step 3: Run full test suite**

Run: `uv run pytest tests/ -v -m "not integration"`
Expected: All PASS.

**Step 4: Commit**

```bash
git add tests/test_tool_modes.py
git commit -m "test(tools): replace always-true assertion with structlog capture_logs"
```

---

### Task 4: Add M1.5 milestone logs (P3)

**Problem:** Per CLAUDE.md governance rules，每个 milestone 需要 `dev_docs/logs/{milestone}_{YYYY-MM-DD}/{role}.md`。M1.5 只有 `dev_docs/logs/README.md`。

**Files:**
- Create: `dev_docs/logs/m1.5_2026-02-21/developer.md`

**Step 1: Create log after implementation completes**

此 task 在 Task 1-3 全部实现并验证通过后执行。日志内容基于实际执行记录填写，调用次数附可核对的命令/标识。模板框架：

```markdown
# M1.5 Tool Modes — Developer Log

**Milestone:** M1.5 Tool Modes (含 review-fixes)
**Date:** 2026-02-21
**Role:** Developer (solo implementation)

## Skills / Tools Used

| Tool/Skill | Calls | 典型场景 | 效果评估 | 可核对依据 |
|---|---|---|---|---|
| (实现完成后据实填写) | | | | (附 commit hash / 命令) |

## Key Decisions

(据实填写)

## Issues Encountered

(据实填写)

## Recommendations for Next Milestones

(据实填写)
```

**Step 2: Verify log exists**

Run: `ls dev_docs/logs/m1.5_2026-02-21/developer.md`
Expected: File exists.

**Step 3: Commit**

```bash
git add dev_docs/logs/m1.5_2026-02-21/developer.md
git commit -m "docs(tools): add M1.5 milestone developer log"
```

---

## Verification Checklist

After all 4 tasks, run full verification:

```bash
just test-unit          # Expected: all PASS (123+ tests)
just test-integration   # Expected: 26 PASS (24 existing + 2 new in test_tool_modes_integration)
just test-frontend      # Expected: 16 PASS (13 existing + 3 new)
just lint               # Expected: clean (covers src/)
uv run ruff check tests/  # Expected: clean (just lint 不覆盖 tests/)
```

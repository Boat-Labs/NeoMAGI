# M1.5 Tool Modes 测试计划

> 状态：v1（开发前基线）
> 日期：2026-02-21
> 依据：`dev_docs/plans/m1.5_tool-modes_2026-02-20.md`、ADR 0025、ADR 0026

---

## 1. Requirement-Evidence Matrix v1

### 用例 A：chat_safe 会话中，允许工具可执行，受限工具被明确拒绝

| # | 验证行为 | 验证方法 | 预期证据 | 状态 |
|---|----------|----------|----------|------|
| A1 | `current_time` 在 chat_safe 下可执行 | 单元测试 | `test_tool_modes::test_current_time_allowed_in_chat_safe` — `registry.check_mode("current_time", ToolMode.chat_safe)` 返回 True | 待实现 |
| A2 | `memory_search` 在 chat_safe 下可执行 | 单元测试 | `test_tool_modes::test_memory_search_allowed_in_chat_safe` — `registry.check_mode("memory_search", ToolMode.chat_safe)` 返回 True | 待实现 |
| A3 | `read_file` 在 chat_safe 下**不可见**（暴露闸门） | 单元测试 | `test_tool_modes::test_read_file_not_in_chat_safe_schema` — `registry.get_tools_schema(ToolMode.chat_safe)` 返回的工具列表不含 `read_file` | 待实现 |
| A4 | `read_file` 在 chat_safe 下**不可执行**（执行闸门） | 单元测试 | `test_tool_modes::test_read_file_denied_in_chat_safe` — `registry.check_mode("read_file", ToolMode.chat_safe)` 返回 False | 待实现 |
| A5 | 执行闸门拒绝后，模型收到结构化 error dict | 单元测试 | `test_tool_modes::test_execute_tool_returns_mode_denied_dict` — `_execute_tool("read_file", ...)` 在 chat_safe 下返回 `{"ok": False, "error_code": "MODE_DENIED", "tool_name": "read_file", "mode": "chat_safe", ...}` | 待实现 |
| A6 | 执行闸门拒绝后，AgentLoop yield `ToolDenied` 事件 | 单元测试 | `test_tool_modes::test_agent_yields_tool_denied_event` — `handle_message()` 在 read_file 被拒绝时产出 `ToolDenied` 事件 | 待实现 |
| A7 | 拒绝事件经 Gateway 转为 `tool_denied` RPC frame 发给前端 | 集成测试 | `test_tool_modes_integration::test_tool_denied_websocket_frame` — WebSocket 客户端收到 `{"type": "tool_denied", ...}` 且包含正确字段 | 待实现 |
| A8 | 拒绝后模型可继续生成文字回复（不终止对话） | 集成测试 | `test_tool_modes_integration::test_tool_denied_then_text_continues` — 收到 tool_denied 后仍收到 stream_chunk + done=true | 待实现 |
| A9 | `read_file` 在 coding 下可见可执行（矩阵正向验证） | 单元测试 | `test_tool_modes::test_read_file_allowed_in_coding` — `check_mode` 返回 True，`get_tools_schema(ToolMode.coding)` 包含 read_file | 待实现 |
| A10 | Prompt tooling layer 按 mode 过滤，与 schema 同源 | 单元测试 | `test_tool_modes::test_prompt_tooling_matches_schema` — `_layer_tooling(mode)` 输出的工具集合 == `list_tools(mode)` 返回的集合 | 待实现 |
| A11 | Safety layer 注入 mode 感知内容 | 单元测试 | `test_tool_modes::test_safety_layer_mentions_mode` — `_layer_safety(ToolMode.chat_safe)` 输出包含当前 mode 标识和受限说明 | 待实现 |

### 用例 B：mode 由 SessionManager 管理，异常时 fail-closed

| # | 验证行为 | 验证方法 | 预期证据 | 状态 |
|---|----------|----------|----------|------|
| B1 | 默认 mode 来自 `SessionSettings.default_mode` 配置 | 单元测试 | `test_tool_modes::test_default_mode_from_config` — `SessionSettings()` 默认值为 `"chat_safe"` | 待实现 |
| B2 | `SessionManager.get_mode()` 从 DB 读取 session mode | 集成测试 | `test_tool_modes_integration::test_get_mode_reads_from_db` — 新建 session 后 `get_mode()` 返回 `ToolMode.chat_safe` | 待实现 |
| B3 | M1.5 阶段不开放 `set_mode()` 外部写接口 | 代码审查 | `SessionManager` 无 `set_mode` 公开方法；grep 确认无 `set_mode` RPC handler | 待实现 |
| B4 | 模型无权自行切换 mode | 架构审查 | mode 仅在 `handle_message()` 入口从 SessionManager 读取，不接受模型输出影响 | 待实现 |
| B5 | DB 异常时 fail-closed 到 chat_safe | 单元测试 | `test_tool_modes::test_get_mode_db_error_fallback` — mock DB 抛异常 → 返回 `ToolMode.chat_safe` + warning 日志 | 待实现 |
| B6 | DB 中无效枚举值时 fail-closed 到 chat_safe | 单元测试 | `test_tool_modes::test_get_mode_invalid_value_fallback` — DB 返回 `"nonexistent_mode"` → 返回 `ToolMode.chat_safe` + warning 日志 | 待实现 |
| B7 | DB 中 mode=coding 时 fail-closed 到 chat_safe（M1.5 护栏） | 单元测试 | `test_tool_modes::test_get_mode_coding_downgrades_in_m15` — DB 返回 `"coding"` → 返回 `ToolMode.chat_safe` + warning 日志 | 待实现 |
| B8 | `SESSION_DEFAULT_MODE` 设为非 chat_safe 时配置校验失败 | 单元测试 | `test_config_schema::test_session_default_mode_non_chat_safe_rejected` — raise `ValidationError` 且包含 ADR 0025 引用 | 待实现 |

### 用例 C：越权调用不静默执行，用户 deterministic 感知

| # | 验证行为 | 验证方法 | 预期证据 | 状态 |
|---|----------|----------|----------|------|
| C1 | tool_denied 事件包含全部 6 个字段 | 单元测试 | `test_tool_modes::test_tool_denied_event_fields_complete` — ToolDenied 实例含 `tool_name, call_id, mode, error_code, message, next_action` 且均非空 | 待实现 |
| C2 | 同一越权调用总是产出相同的 tool_denied 结果 | 单元测试 | `test_tool_modes::test_tool_denied_deterministic` — 多次调用同一越权场景，输出一致 | 待实现 |
| C3 | 拒绝事件作为 tool role 消息持久化到 session transcript | 集成测试 | `test_tool_modes_integration::test_denial_persisted_to_transcript` — DB 中对应 session 的 messages 包含 tool role 消息，内容含 `MODE_DENIED` | 待实现 |
| C4 | 前端通过 tool_denied 事件类型可 deterministic 区分拒绝与其他事件 | 集成测试 | `test_tool_modes_integration::test_tool_denied_type_distinguishable` — tool_denied frame 的 `type` 字段值为 `"tool_denied"`，与 `stream_chunk`/`tool_call`/`error` 明确区分 | 待实现 |

---

## 2. 高风险场景清单

### 2.1 功能正确性

| # | 场景 | 风险等级 | 验证策略 |
|---|------|----------|----------|
| F1 | mode 过滤准确性：chat_safe 下 3 个内置工具的可见/不可见是否符合准入矩阵 | 高 | 单元测试遍历所有工具 × 所有 mode 组合，断言结果与矩阵一致 |
| F2 | override 交集逻辑：`effective_modes = tool.allowed_modes ∩ override`，收紧正确、放宽拒绝 | 高 | 单元测试：(1) 无 override 时 effective == self-declared；(2) override 为子集时 effective == override；(3) override 含 tool 未声明的 mode 时 raise ValueError |
| F3 | `check_mode()` 各组合：注册工具 + 合法 mode、注册工具 + 非法 mode、未注册工具名 | 高 | 单元测试覆盖 3×2 矩阵 + 边界 |
| F4 | `get_tools_schema(mode)` 返回的 JSON schema 格式正确（OpenAI function calling 格式） | 中 | 单元测试验证返回 list[dict]，每项含 `type: "function"` + `function.name/description/parameters` |
| F5 | `list_tools(mode)` 与 `get_tools_schema(mode)` 过滤结果一致（同源保证） | 高 | 单元测试断言 `{t.name for t in list_tools(mode)} == {s["function"]["name"] for s in get_tools_schema(mode)}` |

### 2.2 边界条件

| # | 场景 | 风险等级 | 验证策略 |
|---|------|----------|----------|
| E1 | 工具 `allowed_modes` 为空 frozenset（fail-closed 默认值） | 高 | 单元测试：`BaseTool` 子类不覆写 allowed_modes → 在所有 mode 下不可见且不可执行 |
| E2 | 未注册工具名的 `check_mode()` 调用 | 中 | 单元测试：`check_mode("nonexistent_tool", ToolMode.chat_safe)` 返回 False（或特定行为，需与设计对齐） |
| E3 | 无效 mode 值传入 `get_tools_schema()`/`check_mode()` | 中 | 单元测试：传入非 ToolMode 枚举值时行为明确（类型系统应阻止，但防御性测试仍需要） |
| E4 | `set_mode_override()` 对未注册工具设置 override | 低 | 单元测试：应 raise 错误或静默忽略（需与设计对齐） |
| E5 | 同一工具多次 `set_mode_override()` | 低 | 单元测试：后设覆盖前设，最终 effective_modes 以最后一次为准 |
| E6 | `handle_message` 中 mode 参数传递链路完整：get_mode → schema → check_mode | 高 | 集成测试验证全链路一致性 |

### 2.3 回归影响分析

现有 9 个测试文件（6 单元 + 3 集成），需逐一评估受 mode 参数变更影响：

| 测试文件 | 影响程度 | 具体影响 | 适配策略 |
|----------|----------|----------|----------|
| `test_agent_tool_parse.py` | **高** | `AgentLoop.__init__` 签名可能变化；`_execute_tool` 新增 mode 参数；registry mock 需适配 `get_tools_schema(mode)` | 更新 mock 的 `get_tools_schema` 和 `list_tools` 调用签名，传入 mode 参数 |
| `test_config_schema.py` | **中** | 新增 `SessionSettings` 相关测试 | 新增测试用例，现有用例不受影响 |
| `test_model_client_choices_guard.py` | 无 | ModelClient 接口不变 | 无需修改 |
| `test_read_file_security.py` | 无 | ReadFileTool.execute 行为不变，mode 检查在上层 | 无需修改 |
| `test_session_history_filter.py` | 无 | 历史过滤逻辑不变 | 无需修改 |
| `test_session_serialization.py` | **低** | Session 模型新增 mode 字段，但序列化测试可能不受影响 | 视实现决定 |
| `test_session_persistence.py` | **低** | 可能需要验证 mode 字段持久化 | 视实现决定 |
| `integration/test_tool_loop_flow.py` | **高** | `_make_app` 中 ToolRegistry/AgentLoop 构造需传 mode 相关参数；EchoTool/FailingTool 需覆写 `group`/`allowed_modes`；`_send_and_collect` 可能需处理 `tool_denied` 消息类型 | 测试工具类需声明 allowed_modes；_make_app 需适配新的 SessionManager 签名 |
| `integration/test_websocket.py` | **中** | `_make_app` 中 SessionManager 构造可能需要 `default_mode` 参数；`_collect_until_done` 需处理 tool_denied 事件（当前遇到 tool_denied 不会 break 循环） | 适配构造签名；验证 tool_denied 不影响 done 判断逻辑 |
| `integration/test_session_db.py` | **低** | session 表新增 mode 列，但主要测试 locking/fencing 逻辑 | 迁移后自动适配 |

**关键回归风险**：`test_tool_loop_flow.py` 中的 `EchoTool` 和 `FailingTool` 未覆写 `allowed_modes`，在 M1.5 后默认值为 `frozenset()`（fail-closed），将导致这些工具在任何 mode 下不可见/不可执行，**所有使用这些工具的测试将失败**。

**缓解方案**：测试工具类必须显式声明 `allowed_modes = frozenset({ToolMode.chat_safe, ToolMode.coding})`，确保在测试 mode 下可用。

### 2.4 安全/越权

| # | 场景 | 风险等级 | 验证策略 |
|---|------|----------|----------|
| S1 | 模型 hallucinate 工具名绕过暴露闸门 | 高 | 单元测试：模型返回 `tool_calls=[{"name": "write_file", ...}]`（未注册工具）→ 执行闸门拦截 → 返回 TOOL_NOT_FOUND 错误（已有逻辑）+ 不触发 MODE_DENIED（区分错误类型） |
| S2 | 模型 hallucinate 已注册但当前 mode 不可用的工具名 | **高** | 单元测试：模型返回 `tool_calls=[{"name": "read_file", ...}]` 在 chat_safe 下 → 执行闸门拦截 → 返回 MODE_DENIED → yield ToolDenied 事件 |
| S3 | DB 被手动改为 `mode='coding'` | 高 | 单元测试（B7）：`get_mode()` 护栏 → 降级 chat_safe + warning |
| S4 | DB 被手动改为 `mode=NULL` 或字段缺失 | 中 | 单元测试（B6 变体）：`get_mode()` fail-closed → chat_safe |
| S5 | 环境变量 `SESSION_DEFAULT_MODE` 被恶意设为 `coding` | 中 | 单元测试（B8）：配置校验拒绝 → ValueError |

### 2.5 可观测性

| # | 场景 | 风险等级 | 验证策略 |
|---|------|----------|----------|
| O1 | 拒绝事件正确审计落盘到 session transcript | 高 | 集成测试（C3）：DB 中 tool role 消息含 MODE_DENIED payload |
| O2 | 使用默认 `allowed_modes` 注册工具时触发 warning 日志 | 中 | 单元测试：`caplog` 捕获 `tool_registered_with_default_modes` warning |
| O3 | M1.5 护栏降级时触发 warning 日志 | 高 | 单元测试（B5/B6/B7）：`caplog` 捕获降级 warning 且含上下文信息（原值、session_id） |
| O4 | 正常工具执行不产生虚假 warning | 中 | 单元测试：chat_safe 下执行 current_time，无 mode 相关 warning 日志 |

---

## 3. M1.5 阶段护栏验证场景

基于 ADR 0025（line 10: M1.5 固定 chat_safe）和 ADR 0026（line 36: 缺失或异常时 fail-closed 到 chat_safe）。

### 3.1 DB 中 session.mode = 'coding' → 降级 chat_safe + warning

```
前提条件：session 记录存在，mode 字段值为 'coding'（手动 SQL 修改）
操作：SessionManager.get_mode(session_id)
预期：
  - 返回值：ToolMode.chat_safe
  - 日志：structlog warning，含 "mode_downgraded" 或等效标识
  - 日志上下文：原始值 'coding'、session_id、降级原因 "M1.5 only supports chat_safe"
```

**测试用例**：`test_tool_modes::test_get_mode_coding_downgrades_in_m15`
- mock DB 返回 `mode="coding"`
- 断言 `get_mode()` 返回 `ToolMode.chat_safe`
- 断言 warning 日志被记录

### 3.2 DB 中 session.mode = 无效值 → 降级 chat_safe + warning

```
前提条件：session 记录存在，mode 字段值为 'admin'（非法枚举值）
操作：SessionManager.get_mode(session_id)
预期：
  - 返回值：ToolMode.chat_safe
  - 日志：structlog warning，含 "invalid_mode_value" 或等效标识
  - 日志上下文：原始值 'admin'、session_id
```

**测试用例**：`test_tool_modes::test_get_mode_invalid_value_fallback`
- mock DB 返回 `mode="admin"`
- 断言 `get_mode()` 返回 `ToolMode.chat_safe`
- 断言 warning 日志被记录

### 3.3 DB 查询异常 → 降级 chat_safe + warning

```
前提条件：DB 连接异常（网络超时、连接池耗尽等）
操作：SessionManager.get_mode(session_id)
预期：
  - 返回值：ToolMode.chat_safe
  - 日志：structlog warning，含 "mode_read_error" 或等效标识
  - 日志上下文：异常类型、session_id
  - 不抛异常：方法正常返回，不中断请求处理
```

**测试用例**：`test_tool_modes::test_get_mode_db_error_fallback`
- mock DB 抛 `SQLAlchemyError` 或 `Exception`
- 断言 `get_mode()` 返回 `ToolMode.chat_safe`
- 断言 warning 日志被记录
- 断言无异常传播

### 3.4 SESSION_DEFAULT_MODE 环境变量设为 'coding' → 配置校验 raise ValueError

```
前提条件：环境变量 SESSION_DEFAULT_MODE=coding
操作：SessionSettings() 实例化
预期：
  - 抛出 pydantic ValidationError
  - 错误消息包含 "chat_safe" 和 "ADR 0025"
  - 应用无法启动（fail-fast）
```

**测试用例**：`test_config_schema::test_session_default_mode_non_chat_safe_rejected`
- `monkeypatch.setenv("SESSION_DEFAULT_MODE", "coding")`
- `pytest.raises(ValidationError)`
- 断言错误消息包含 ADR 引用

---

## 4. ToolDeniedData 协议审查

### 4.1 字段完整性分析

设计方案中的 `ToolDeniedData` 定义：

```python
class ToolDeniedData(BaseModel):
    call_id: str       # 关联模型生成的 tool_call id
    tool_name: str     # 被拒绝的工具名
    mode: str          # 当前会话 mode
    error_code: str    # 错误码（"MODE_DENIED"）
    message: str       # 人类可读拒绝说明
    next_action: str   # 用户下一步指引
```

**逐字段审查**：

| 字段 | 前端展示需求 | 审查结论 | 备注 |
|------|-------------|----------|------|
| `call_id` | 必需：用于关联 tool_call 事件，前端需要将拒绝与对应的工具调用请求匹配 | **充分** | 与现有 `ToolCallData.call_id` 一致 |
| `tool_name` | 必需：展示被拒绝的工具名称 | **充分** | 与现有 `ToolCallData.tool_name` 一致 |
| `mode` | 必需：告知用户当前处于什么模式 | **充分** | 使用 str 而非 enum，便于序列化和前端解析 |
| `error_code` | 必需：前端可据此做条件渲染（如不同 error_code 显示不同图标/文案） | **充分** | 当前仅 `MODE_DENIED`，留有扩展空间 |
| `message` | 必需：直接展示给用户的拒绝原因 | **充分** | 人类可读，可直接用于 toast/tooltip |
| `next_action` | 必需：指导用户下一步操作 | **需审慎** — 见下方分析 | |

### 4.2 与现有 tool_call 事件的一致性

| 维度 | `RPCToolCall` | `RPCToolDenied` | 一致性 |
|------|--------------|-----------------|--------|
| 顶层 `type` 字段 | `"tool_call"` | `"tool_denied"` | 一致（命名规范统一，前端可用 switch/case 分发） |
| 顶层 `id` 字段 | 请求关联 ID | 请求关联 ID | 一致 |
| data 中工具标识 | `tool_name` | `tool_name` | 一致 |
| data 中调用标识 | `call_id` | `call_id` | 一致 |
| data 中参数/payload | `arguments: dict` | `error_code + message + next_action` | 合理差异：denied 不含 arguments，改为错误描述 |

**结论**：协议一致性良好，前端可复用现有 tool_call 的关联逻辑（通过 call_id），仅需新增 `tool_denied` 分支处理。

### 4.3 next_action 阶段可达性审查

设计方案中 `next_action` 示例文案：

> "当前会话处于 chat_safe 模式，该工具需要 coding 模式。coding 模式将在后续版本开放。"

**审查结论**：

| 检查项 | 结果 | 说明 |
|--------|------|------|
| 是否引导用户执行 M1.5 不可达操作？ | **否** — 合格 | 文案说"后续版本开放"，未提供切换操作指引 |
| 是否暗示用户可以手动切换 mode？ | **否** — 合格 | 未出现"请切换到 coding 模式"等语句 |
| 是否含有未实现功能的操作入口？ | **否** — 合格 | 无 RPC 方法名、按钮名称等引导 |
| 后续阶段开放 coding 时是否需要更新？ | **是** — 标记 | 开放 coding 后需更新 next_action 文案为可达操作（如 "请使用 /mode coding 切换"） |

**建议**：next_action 文案应硬编码在 M1.5 代码中，便于后续阶段通过改代码更新，而非运行时配置化（避免过度工程）。

### 4.4 缺失字段评估

| 潜在字段 | 是否需要 | 理由 |
|----------|----------|------|
| `timestamp` | **否** | RPC frame 发送时机即为事件时间；transcript 持久化自带 `created_at` |
| `session_id` | **否** | WebSocket 连接已在 session 上下文中；前端已知当前 session |
| `required_mode` | **可选（建议不加）** | `message` 字段已含自然语言说明；M1.5 只有两个 mode，增加字段收益低于复杂度代价 |
| `available_modes` | **否** | M1.5 只有 chat_safe 生效，列出可用 mode 无实际意义 |

**结论**：当前 6 个字段对 M1.5 阶段充分，无需新增。

---

## 5. 测试执行清单（汇总）

### 5.1 新增单元测试（`tests/test_tool_modes.py`）

| 测试名 | 对应矩阵项 |
|--------|-----------|
| `test_tool_group_enum_values` | 基础 |
| `test_tool_mode_enum_values` | 基础 |
| `test_base_tool_default_group_is_code` | 基础 |
| `test_base_tool_default_allowed_modes_is_empty` | E1 |
| `test_current_time_group_and_modes` | A1 |
| `test_memory_search_group_and_modes` | A2 |
| `test_read_file_group_and_modes` | A3, A4 |
| `test_current_time_allowed_in_chat_safe` | A1 |
| `test_memory_search_allowed_in_chat_safe` | A2 |
| `test_read_file_not_in_chat_safe_schema` | A3 |
| `test_read_file_denied_in_chat_safe` | A4 |
| `test_read_file_allowed_in_coding` | A9 |
| `test_all_tools_in_coding_schema` | A9 |
| `test_override_tightens_modes` | F2 |
| `test_override_loosen_raises_value_error` | F2 |
| `test_override_intersection_logic` | F2 |
| `test_check_mode_unregistered_tool` | E2 |
| `test_list_tools_matches_get_tools_schema` | F5 |
| `test_fail_closed_default_tool_invisible` | E1 |
| `test_fail_closed_default_tool_not_executable` | E1 |
| `test_registration_warning_for_default_modes` | O2 |
| `test_builtins_all_override_group_and_modes` | 声明守卫 |
| `test_builtins_all_have_nonempty_allowed_modes` | 声明守卫 |
| `test_execute_tool_returns_mode_denied_dict` | A5 |
| `test_mode_denied_dict_fields` | A5 |
| `test_mode_denied_next_action_stage_appropriate` | next_action |
| `test_agent_yields_tool_denied_event` | A6 |
| `test_tool_denied_event_fields_complete` | C1 |
| `test_tool_denied_deterministic` | C2 |
| `test_prompt_tooling_matches_schema` | A10 |
| `test_safety_layer_mentions_mode` | A11 |
| `test_get_mode_coding_downgrades_in_m15` | B7 / 3.1 |
| `test_get_mode_invalid_value_fallback` | B6 / 3.2 |
| `test_get_mode_db_error_fallback` | B5 / 3.3 |
| `test_no_false_warning_on_normal_execution` | O4 |

### 5.2 新增配置测试（`tests/test_config_schema.py` 扩展）

| 测试名 | 对应矩阵项 |
|--------|-----------|
| `test_session_default_mode_default_value` | B1 |
| `test_session_default_mode_chat_safe_accepted` | B1 |
| `test_session_default_mode_non_chat_safe_rejected` | B8 / 3.4 |
| `test_root_settings_includes_session` | B1 |

### 5.3 新增集成测试（`tests/integration/test_tool_modes_integration.py`）

| 测试名 | 对应矩阵项 |
|--------|-----------|
| `test_tool_denied_websocket_frame` | A7 |
| `test_tool_denied_then_text_continues` | A8 |
| `test_chat_safe_allowed_tool_works` | A1, A2 |
| `test_denial_persisted_to_transcript` | C3 |
| `test_tool_denied_type_distinguishable` | C4 |
| `test_get_mode_reads_from_db` | B2 |

### 5.4 现有测试适配（回归）

| 文件 | 需要的适配 |
|------|-----------|
| `test_agent_tool_parse.py` | registry mock 的 `get_tools_schema` 和 `list_tools` 需接受 `mode` 参数 |
| `integration/test_tool_loop_flow.py` | `EchoTool`/`FailingTool` 覆写 `allowed_modes`；`_make_app` 中 SessionManager 适配；`_send_and_collect` 处理 tool_denied |
| `integration/test_websocket.py` | `_make_app` 中 SessionManager 构造适配；`_collect_until_done` 可能需处理 tool_denied |

---

## 6. 关键发现与风险提示

### 发现 1：测试工具类回归风险（高）
现有 `test_tool_loop_flow.py` 中的 `EchoTool` 和 `FailingTool` 未覆写 `allowed_modes`。M1.5 引入 fail-closed 默认值后，这些工具将在任何 mode 下不可用，**导致 6 个集成测试全部失败**。

**建议**：开发者在实现 BaseTool 变更时，必须同步更新所有测试工具类。建议在 PR checklist 中加入"测试工具类声明检查"。

### 发现 2：暴露闸门与执行闸门的双重防御需同步验证
暴露闸门（get_tools_schema 过滤）和执行闸门（check_mode 校验）是独立防线。测试必须分别验证两者，且验证它们在模型绕过暴露闸门（hallucinate 工具名）时执行闸门仍能拦截。

### 发现 3：tool_denied 不应中断现有事件收集逻辑
`_send_and_collect` 和 `_collect_until_done` 当前以 `stream_chunk done=true` 或 `error` 终止收集。`tool_denied` 是中间事件（不终止对话），这些辅助函数需要更新为：遇到 `tool_denied` 时继续收集，不提前退出。

### 发现 4：ToolDeniedData 协议字段充分且阶段可达
6 个字段覆盖前端展示所需信息。next_action 文案未引导用户执行 M1.5 不可达操作。无需新增字段。

### 发现 5：mode 参数贯穿签名变更影响面广
`ToolRegistry.get_tools_schema(mode)`、`ToolRegistry.list_tools(mode)`、`PromptBuilder.build(session_id, mode)` 均新增必填 mode 参数。所有调用方（AgentLoop、PromptBuilder、测试代码）必须同步更新。建议开发者使用 grep 全量搜索 `get_tools_schema\(` 和 `list_tools\(` 确保无遗漏。

# M1.5 Tool Modes 设计方案

> 状态：approved
> 日期：2026-02-20
> 依据：`design_docs/roadmap_milestones_v3.md`、`design_docs/m1_5_architecture.md`、ADR 0024/0025/0026

## 1. 目标

在不引入复杂权限系统的前提下，建立 mode 授权框架与双闸门，以 `chat_safe` 验证可控执行边界。

核心交付：
- 工具按组分类，按模式授权。
- 暴露闸门：模型只看到当前 mode 允许的工具 schema。
- 执行闸门：工具执行前二次校验，越权调用被明确拒绝。
- 拒绝反馈：模型收结构化错误 + 前端收专用事件 + 审计落盘。
- M1.5 固定 `chat_safe`，`coding` 仅预留定义。

## 2. 数据模型

### 2.1 枚举定义（`src/tools/base.py`）

```python
from enum import Enum

class ToolGroup(str, Enum):
    code = "code"       # 代码读写执行（read/write/edit/bash）
    memory = "memory"   # 记忆检索与写入（memory_search, memory_append）
    world = "world"     # 环境信息（current_time 等）

class ToolMode(str, Enum):
    chat_safe = "chat_safe"   # 默认安全模式
    coding = "coding"         # 任务模式（M1.5 预留，不开放切换）
```

### 2.2 BaseTool 元数据（fail-closed 默认值）

在 `BaseTool` 新增两个 **具体属性（非抽象）**，默认值为 fail-closed：

```python
class BaseTool(ABC):
    # ... 已有抽象属性：name, description, parameters, execute

    @property
    def group(self) -> ToolGroup:
        """Tool group for organization/display/audit.
        Default: code (most restrictive group, conservative fallback).
        NOTE: group is NOT an authorization source — see allowed_modes.
        """
        return ToolGroup.code

    @property
    def allowed_modes(self) -> frozenset[ToolMode]:
        """Modes in which this tool is available.
        Default: empty frozenset (fail-closed — unavailable in all modes).
        Real tools MUST override to declare their access.
        """
        return frozenset()
```

设计约束：
- **`allowed_modes` 是唯一授权依据**。安全判断只看 `allowed_modes`（与 override 交集），不以 `group` 作为放行条件。
- **`group` 仅用于组织/展示/审计**，是保守兜底分类（默认 `code`），不参与授权决策。
- 默认值为 fail-closed：未显式声明的工具在任何 mode 下均不可用。
- 测试桩和临时工具类零改动即可编译，默认不可用（安全）。

### 2.3 工具准入矩阵

| 工具 | group | allowed_modes | chat_safe 可用 | coding 可用 |
|---|---|---|---|---|
| `current_time` | `world` | `{chat_safe, coding}` | Yes | Yes |
| `memory_search` | `memory` | `{chat_safe, coding}` | Yes | Yes |
| `read_file` | `code` | `{coding}` | **No** | Yes |

设计决策：
- 元数据由工具自声明（group + allowed_modes 为具体属性，有 fail-closed 默认值）。
- ToolRegistry 保留可选 override，只能"收紧"不能放宽（与自身声明取交集）。

### 2.4 默认元数据告警与声明检查

- **注册告警**：ToolRegistry 注册工具时，若检测到 `allowed_modes` 为空（即使用默认值），记录 `structlog.warning("tool_registered_with_default_modes")`，提醒开发者显式声明。
- **内置工具测试守卫**：新增测试用例，断言所有通过 `register_builtins` 注册的内置工具必须**显式覆写** `group` 和 `allowed_modes` 属性。检查方式为 property 身份比较（`type(tool).group is not BaseTool.group`），而非值比较——避免工具目标 group 恰好等于默认值时产生误判（例如 `read_file` 目标 group 为 `code`，与默认值相同但确实是显式声明的）。

## 3. 双闸门

### 3.1 授权规则（严格 fail-closed）

```
effective_modes(tool) = tool.allowed_modes ∩ override.get(tool.name, tool.allowed_modes)
```

- `allowed_modes` 默认 `frozenset()`（空集）。
- 无 override 时，`effective_modes = tool.allowed_modes`。
- 有 override 时，取交集（只收紧不放宽）。
- Override 不可包含工具自身 `allowed_modes` 之外的 mode（fail-fast：`set_mode_override` 直接 raise ValueError）。

### 3.2 暴露闸门（Exposure Gate）

位于 `ToolRegistry.get_tools_schema(mode: ToolMode)`：
- **`mode` 为必填参数**，无默认值，无 None=all 后门。
- 过滤逻辑：只返回 `mode ∈ effective_modes(tool)` 的工具 schema。
- 模型只看到当前 mode 允许的工具，从源头减少越权尝试。

### 3.3 执行闸门（Execution Gate）

位于 `AgentLoop._execute_tool()` 中，tool lookup 之后、`tool.execute()` 之前：
- 调用 `registry.check_mode(tool_name, mode)` 校验准入。
- **`mode` 为必填参数**，无默认值，与暴露闸门保持一致的 fail-closed 语义。
- 校验失败时触发拒绝链路（见第 4 节）。
- 防御目标：即使模型绕过暴露闸门（如 hallucinate 工具名），执行层仍能拦截。

### 3.4 ToolRegistry 接口变更

```python
class ToolRegistry:
    def __init__(self) -> None:
        self._tools: dict[str, BaseTool] = {}
        self._mode_overrides: dict[str, frozenset[ToolMode]] = {}

    def register(self, tool: BaseTool) -> None:
        """Register a tool. Warns if tool uses default (empty) allowed_modes."""
        ...

    def set_mode_override(self, tool_name: str, modes: frozenset[ToolMode]) -> None:
        """Set override for a tool. Can only tighten (intersect), not loosen.
        Raises ValueError if override contains modes not in tool's allowed_modes.
        """
        ...

    def list_tools(self, mode: ToolMode) -> list[BaseTool]:
        """Return tools allowed in given mode. mode is REQUIRED (no None=all).
        Used by PromptBuilder tooling layer to ensure prompt text and schema are same-source.
        """
        ...

    def get_tools_schema(self, mode: ToolMode) -> list[dict]:
        """Return tools schema filtered by mode. mode is REQUIRED (no None=all).
        Delegates to list_tools(mode) to guarantee same filtering logic.
        """
        ...

    def check_mode(self, tool_name: str, mode: ToolMode) -> bool:
        """Check if tool is allowed in given mode. Returns False if denied."""
        ...

    def get_effective_modes(self, tool_name: str) -> frozenset[ToolMode]:
        """Get effective allowed modes = tool.allowed_modes ∩ override."""
        ...
```

## 4. 拒绝反馈链路

当执行闸门拒绝越权调用时，三条链路同时生效：

### 4.1 模型反馈

返回结构化 error dict 作为 tool role 消息：

```python
{
    "ok": False,
    "error_code": "MODE_DENIED",
    "tool_name": "read_file",
    "mode": "chat_safe",
    "message": "read_file is not allowed in chat_safe mode",
    "next_action": "当前会话处于 chat_safe 模式，该工具需要 coding 模式。coding 模式将在后续版本开放。"
}
```

- `next_action` 使用阶段可达文案，不引导用户执行 M1.5 不可达的操作。
- 模型收到后可用自然语言向用户解释原因。

### 4.2 前端反馈

AgentLoop yield `ToolDenied` 事件，Gateway 转为 `tool_denied` RPC frame：

```python
# Agent 事件
@dataclass
class ToolDenied:
    tool_name: str
    call_id: str
    mode: str
    error_code: str = "MODE_DENIED"
    message: str = ""
    next_action: str = ""

# Gateway RPC frame
class RPCToolDenied(BaseModel):
    type: Literal["tool_denied"] = "tool_denied"
    id: str
    data: ToolDeniedData

class ToolDeniedData(BaseModel):
    call_id: str
    tool_name: str
    mode: str
    error_code: str
    message: str
    next_action: str
```

`tool_denied` 不终止整轮对话（模型可继续生成文本回复）。

### 4.3 审计落盘

拒绝事件以 tool role 消息持久化到 session transcript：
- `session_manager.append_message(session_id, "tool", json.dumps(denial_result), tool_call_id=tc["id"])`
- 便于后续审计与回放。

## 5. Mode 存储与传递

> 本节对齐 ADR 0026（session-mode-storage-and-propagation）。

### 5.1 Session 模型扩展

会话模型新增 `mode` 字段，持久化到 DB：

```python
# session 表新增列（Alembic 迁移）
mode: str = "chat_safe"  # NOT NULL, DEFAULT 'chat_safe'
```

**历史数据兼容硬约束**：迁移脚本中 `ALTER TABLE ... ADD COLUMN mode ... DEFAULT 'chat_safe' NOT NULL`，确保已有 session 记录升级后 mode 字段均为 `chat_safe`（非空），可被 `get_mode()` 正确读取。

- 默认值来自配置 `SessionSettings.default_mode`（默认 `chat_safe`），仅用于新 session 初始化。
- **M1.5 阶段强约束**：`SessionSettings.default_mode` 通过 `field_validator` 强制校验为 `chat_safe`（参照 `DatabaseSettings._validate_schema` 先例，见 ADR 0025）。后续开放 `coding` 时由新 ADR 放松此约束。
- M1.5 阶段 mode 只读，不开放外部写接口（`set_mode` RPC 不实现）。

### 5.2 SessionManager 扩展

```python
class SessionManager:
    def get_mode(self, session_id: str) -> ToolMode:
        """Get current mode for session.
        Default from config; fail-closed to chat_safe on any anomaly.
        """
        ...
    # M1.5 不实现 set_mode()，后续阶段通过 RPC 开放
```

### 5.3 Fail-closed 规则

- mode 读取异常（DB 错误、字段缺失、无效枚举值）→ 降级到 `chat_safe`，记 warning 日志。
- **M1.5 阶段护栏**：`get_mode()` 读取到任何非 `chat_safe` 的合法值（如 DB 被手动改为 `coding`）→ 同样 warning + 降级到 `chat_safe`。M1.5 全量会话固定 `chat_safe`，不存在合法的非 `chat_safe` 运行态（见 ADR 0025）。后续开放 `coding` 时由新 ADR 移除此护栏。
- 与 ADR 0026 line 36 对齐："缺失或异常时 fail-closed 到 `chat_safe`"。

### 5.4 配置扩展

```python
# src/config/settings.py
class SessionSettings(BaseSettings):
    """Session settings. Env vars prefixed with SESSION_."""
    model_config = SettingsConfigDict(env_prefix="SESSION_")
    default_mode: str = "chat_safe"

    @field_validator("default_mode")
    @classmethod
    def _validate_default_mode(cls, v: str) -> str:
        """M1.5: enforce chat_safe. See ADR 0025.
        Relax this constraint via new ADR when coding mode is opened.
        """
        if v != ToolMode.chat_safe:
            raise ValueError(
                f"SESSION_DEFAULT_MODE must be 'chat_safe' in M1.5 "
                f"(got '{v}'). See ADR 0025."
            )
        return v
```

**Canonical 环境变量名**：`SESSION_DEFAULT_MODE`（prefix `SESSION_` + field `default_mode`，与项目其他配置命名规则一致：`DATABASE_HOST`、`OPENAI_API_KEY` 等）。ADR 0026 已同步使用此命名。

### 5.5 Root Settings 组合与注入

```python
# src/config/settings.py — Root Settings 新增 session 字段
class Settings(BaseSettings):
    model_config = SettingsConfigDict(extra="ignore")

    database: DatabaseSettings = Field(default_factory=DatabaseSettings)
    openai: OpenAISettings = Field(default_factory=OpenAISettings)
    gateway: GatewaySettings = Field(default_factory=GatewaySettings)
    session: SessionSettings = Field(default_factory=SessionSettings)  # 新增
    workspace_dir: Path = Path("workspace")
```

```python
# src/gateway/app.py — lifespan 中注入默认 mode 来源
settings = get_settings()
session_manager = SessionManager(
    db_session_factory=db_session_factory,
    default_mode=ToolMode(settings.session.default_mode),  # 注入
)
```

SessionManager 持有 `default_mode`，仅用于新 session 初始化时写入 DB。已有 session 从 DB 读取 mode 字段。

### 5.6 传递路径

```
SessionManager.get_mode(session_id)        # 从 DB/内存读取，异常 fail-closed
  → AgentLoop.handle_message() 读取 mode
    → ToolRegistry.get_tools_schema(mode=mode)  # 暴露闸门（mode 必填）
    → ToolRegistry.check_mode(tool_name, mode)   # 执行闸门（mode 必填）
    → PromptBuilder.build(session_id, mode=mode) # 安全层注入
```

## 6. System Prompt 增强

### 6.1 Tooling layer 按 mode 过滤

现有 `_layer_tooling()` 遍历 `self._tool_registry.list_tools()` 列出全部工具。必须改为按 mode 过滤，保证 prompt 文本与 function calling schema 同源：

```python
def _layer_tooling(self, mode: ToolMode) -> str:
    """Generate tooling layer filtered by mode.
    Uses registry.list_tools(mode) to guarantee prompt text
    and function calling schema use identical filtering logic.
    """
    ...
```

若不过滤，模型会在 prompt 中看到 `read_file` 描述但在 schema 中找不到，行为不可预期。

### 6.2 Safety layer 注入 mode 感知

`PromptBuilder._layer_safety()` 从空占位升级为 mode 感知指导：

```python
def _layer_safety(self, mode: ToolMode) -> str:
    """Generate safety layer with mode-aware guidance."""
    # 告知模型当前 mode
    # 列出不可用工具及原因
    # 指示模型在用户需要受限能力时应说明当前 mode 限制
```

### 6.3 `build()` 签名

`session_id` 和 `mode` 均为必填参数，无默认值——调用方必须显式传入，与双闸门"无 None 后门"原则一致：

```python
def build(self, session_id: str, mode: ToolMode) -> str:
```

## 7. 涉及文件变更总览

| 文件 | 变更类型 | 说明 |
|---|---|---|
| `src/tools/base.py` | 修改 | 新增 ToolGroup/ToolMode 枚举；BaseTool 新增 group/allowed_modes 具体属性（fail-closed 默认值） |
| `src/tools/registry.py` | 修改 | mode-aware 过滤（mode 必填）+ override 收紧机制 + check_mode + 注册告警 |
| `src/tools/builtins/current_time.py` | 修改 | 覆写 group=world, allowed_modes={chat_safe, coding} |
| `src/tools/builtins/memory_search.py` | 修改 | 覆写 group=memory, allowed_modes={chat_safe, coding} |
| `src/tools/builtins/read_file.py` | 修改 | 覆写 group=code, allowed_modes={coding} |
| `src/agent/agent.py` | 修改 | 读 mode → 暴露闸门传参 → 执行闸门校验 → yield ToolDenied |
| `src/agent/events.py` | 修改 | 新增 ToolDenied 事件类 |
| `src/agent/prompt_builder.py` | 修改 | tooling layer 按 mode 过滤（同源）；safety layer 注入 mode 感知内容；build(session_id, mode) 均必填无默认值 |
| `src/session/manager.py` | 修改 | 新增 get_mode() + fail-closed 降级逻辑 + M1.5 阶段护栏 |
| `src/session/models.py` | 修改 | session 模型新增 mode 字段 |
| `src/config/settings.py` | 修改 | 新增 SessionSettings.default_mode（含 M1.5 validator）+ Root Settings 新增 session 字段 |
| `alembic/versions/` | 新增 | session 表新增 mode 列迁移（含历史数据兼容） |
| `src/gateway/protocol.py` | 修改 | 新增 RPCToolDenied / ToolDeniedData 消息类型 |
| `src/gateway/app.py` | 修改 | lifespan 注入 default_mode 到 SessionManager + 处理 ToolDenied 事件 → 发送 tool_denied frame |
| `src/infra/errors.py` | 可选 | 新增 ToolModeError（若需要异常路径） |
| `tests/test_tool_modes.py` | 新增 | mode 过滤、执行闸门拒绝、denial 事件流、内置工具声明守卫 |
| `tests/test_tool_modes_integration.py` | 新增 | WebSocket 端到端 tool_denied 流 |

## 8. 测试策略

### 8.1 单元测试

- **ToolRegistry mode 过滤**：chat_safe 模式下 get_tools_schema 不含 read_file；coding 模式下全量返回。
- **Override 收紧**：override 只能收紧不能放宽，交集逻辑验证；尝试放宽时 raise ValueError。
- **check_mode**：各工具在各 mode 下的 True/False。
- **fail-closed 默认值**：未覆写 allowed_modes 的工具在任何 mode 下均不可见/不可执行。
- **注册告警**：使用默认 allowed_modes 注册时触发 warning 日志。
- **内置工具声明守卫**：所有 `register_builtins` 注册的工具必须显式覆写 group 和 allowed_modes（`type(tool).group is not BaseTool.group`），且 allowed_modes 非空。
- **Prompt/Schema 同源**：tooling layer 输出的工具列表与 get_tools_schema 返回的工具集合一致（同一 mode 下）。
- **配置强约束**：`SessionSettings.default_mode` 设为非 `chat_safe` 值时 raise ValidationError。
- **执行闸门拒绝路径**：AgentLoop._execute_tool 在 mode denied 时返回正确 error dict（含阶段可达 next_action）。
- **ToolDenied 事件**：AgentLoop 在拒绝时 yield ToolDenied 事件。
- **SessionManager.get_mode fail-closed**：DB 异常/无效值时降级到 chat_safe；M1.5 阶段护栏：DB 存 `coding` 时同样 warning + 降级到 `chat_safe`。
- **迁移历史数据兼容**：迁移后已有 session 记录的 mode 字段均为 `chat_safe` 且非空。

### 8.2 集成测试

- **tool_denied 端到端**：WebSocket 发 chat.send 触发 read_file 调用 → 收到 tool_denied frame → 模型继续回复 → done frame。
- **正常路径不受影响**：chat_safe 下调用 current_time 仍正常。

### 8.3 现有测试兼容

- 修改现有测试中 ToolRegistry 的使用，确保 mode 参数传递。
- 确保 82 个现有后端测试不被破坏。

## 9. 不做什么（Out of Scope）

- 不实现 `coding` 模式的切换逻辑和 `session.set_mode` RPC。
- 不新增 `write_file`/`edit_file`/`bash` 等 coding 工具。
- 不实现 `memory_append`（归 M3）。
- 不做前端 mode 切换 UI（M1.5 固定 chat_safe）。
- 不引入组织级 RBAC / 策略中心 / 复杂审批工作流。

## 10. 验收标准对齐（来自 roadmap）

- **用例 A**：默认 `chat_safe` 会话中，`current_time`/`memory_search` 可稳定执行；`read_file` 请求被明确拒绝并说明原因（模型文字 + 前端 tool_denied 事件）。
- **用例 B**：mode 由 SessionManager 管理（默认值来自配置），模型不可自行切换；异常时 fail-closed 到 chat_safe。
- **用例 C**：越权调用不会静默执行，用户通过 tool_denied 事件 deterministic 感知控制点。
